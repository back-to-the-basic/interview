import Image from '@site/src/components/Image';

# 다중화와 역다중화

> 트랜스포트 계층 다중화와 역다중화
> 네트워크 계층이 제공하는 호스트 대 호스트 전달 서비스에서 호스트에서 동작하는 애플리케이션에 대한
> 프로세스 대 프로세스 전달 서비스로 확장하는 과정

1. 목적지 호스트에서 트랜스포트 계층은 바로 아래의 네트워크 계층으로부터 `세그먼트`를 수신한다.
   > 트랜스포트 계층은 호스트에서 동작하는 해당 애플리케이션 프로세스에게 이 세그먼트의 데이터를 전달하는 의무를 가진다.
2. 트랜스포트 계층은 세그먼트(데이터)를 중간 매개자인 소켓에게 전달한다.

- 프로세스는 네트워크 애플리케이션의 한 부분으로서 소켓(socket)을 가지고 있다.
- 이는 네트워크에서 프로세스로, 한 프로세스로부터 네트워크로 데이터를 전달하는 출입구 역할을 한다.
- 각각의 소켓은 하나의 유일한 식별자를 가진다.

<Image src="https://user-images.githubusercontent.com/63354527/235612099-45f4c4e6-9b70-47aa-98c3-7bd92709475f.png" />

```
수신한 트랜스포트 계층 세그먼트는 어떻게 적절한 소켓으로 향하는가?
```

각각의 트랜스포트 계층 세그먼트는 세그먼트에 필드 집합을 가지고 있으며,
트랜스포트 계층은 수신 소켓을 식별하기 위해 이러한 필드를 검사한 후 해당 소켓으로 보낸다.

- `역다중화(demultiplexing)`: 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업
- `다중화(multiplexing)`
  - 출발지 호스트에서 소켓으로부터 데이터를 모음
  - 이에 대한 세그먼트를 생성하기 위해 각 데이터에 헤더 정보로 캡슐화
  - 그 세그먼트를 네트워크 계층으로 전달하는 작업

### 트랜스포트 계층 다중화의 두 가지 요구사항

1. 소켓은 유일한 식별자를 갖는다.
2. 각 세그먼트는 세그먼트가 전달될 적절한 소켓을 가리키는 특별한 필드를 갖는다.
   - 출발지 포트 번호 필드(source port number field)
   - 목적지 포트 번호 필드(destination port number field)

<Image src="https://user-images.githubusercontent.com/63354527/235613368-0980df82-3652-44be-bbfb-ee022dccc153.png" />

### 역다중화 서비스의 순서

1. 호스트의 각 소켓은 포트 번호를 할당받음
2. 세그먼트가 호스트에 도착하면,
   - 트랜스포트 계층은 세그먼트 안의 목적지 포트 번호를 검사
   - 그에 상응하는 소켓으로 세그먼트를 보냄
3. 세그먼트의 데이터는 소켓을 통해 해당되는 프로세스로 전달됨

이는 UDP의 기본적인 동작 방식과 같다.

### 비연결형 다중화와 역다중화

> UDP 소켓은 목적지 IP 주소와 목적지 포트 번호로 구성된 두 요소로 된 집합에 의해 식별된다.

따라서 만약 2개의 UDP 세그먼트가 같은 목적지 IP 주소와 목적지 포트 번호를 가진다면,
이 두개의 세그먼트는 같은 목적지 소켓을 통해 같은 프로세스로 향할 것이다.

그렇다면 출발지 포트 번호는 무슨 목적으로 사용되는가?

> 출발지 포트 번호는 회신 주소의 한 부분으로 사용된다.

아래 그림처럼, B가 A에게로 세그먼트를 보내기를 원할 때 B에서 A로 가는 세그먼트의 목적지
포트 번호는 A로 부터 B로 가는 세그먼트의 출발지 포트 번호로부터 가져온다.

### 연결지향형 다중화와 역다중화

> TCP 소켓은 4개의 요소 집합(four-tuple)에 의해 식별된다.

- 출발지 IP 주소
- 출발지 포트번호
- 목적지 IP 주소
- 목적지 포트 번호

특히, 다른 출발지 IP 주소 또는 다른 출발지 포트 번호를 가지고 도착하는 2개의 TCP 세그먼트는
2개의 다른 소켓으로 향하게 된다.(초기 연결 요청을 전달하는 TCP는 제외)

**TCP 연결 설정**

1. TCP 서버 애플리케이션은 `환영 소켓`을 갖고 있다.
   이 소켓은 포트 번호 12000을 가진 **TCP 클라이언트로부터 연결 설정 요청을 기다린다.**

<Image src="https://user-images.githubusercontent.com/63354527/235616160-b892471e-4853-4bba-a5ec-f74db1d6a50d.png" />

2. TCP 클라이언트는 소켓을 생성하고, 연결 설정 요청 세그먼트를 보낸다.

   - 연결 설정 요청은 목적지 포트 번호 12000과 TCP 헤더에 설정된 특별한 연결 설정 비트를 가진 TCP 세그먼트
   - 이 세그먼트는 출발지 포트 번호를 포함하는데, 이것은 클라이언트가 선택한 번호임

3. 서버 프로세스로 동작하는 컴퓨터의 호스트 운영체제가 목적지 포트 12000을 포함하는
   연결 요청 세그먼트를 수신하면, 이 세그먼트를 포트 번호 12000으로 연결 수락을 기다리는 서버
   프로세스로 보낸다.
4. 서버는 연결 요청 세그먼트의 4개 요소의 집합에 주목한다.
   > 서버 호스트는 동시에 존재하는 많은 TCP 소켓을 지원할 수 있다.
   - 새롭게 생성된 연결 소켓은 4개의 요소 집합의 네가지 값에 의해 식별된다.
   - 따라서 그 다음에 도착하는 세그먼트의 출발지 포트, 출발지 IP 주소, 목적지 포트,
     목적지 IP 주소가 전부 일치하면 그 세그먼트는 이 소켓으로 역다중화될 것이다.

### 웹 서버와 TCP

> 서버는 각기 다른 클라이언트가 보낸 세그먼트를 출발지 IP 주소와 출발지 포트번호로 구별한다.

같은 웹 서버 애플리케이션과 통신하기 위해 같은 목적지 포트 번호(80)를 이용하는 두
클라이언트에 대한 예시를 보자.

- 호스트 C가 서버 B로 2개의 HTTP 세션을 시작
- 호스트 A가 서버 B로 하나의 HTTP 세션을 시작

<Image src="https://user-images.githubusercontent.com/63354527/235619013-851a6060-bbec-4350-9d7d-1db870cbfc9a.png" />

호스트 A, 호스트 C, 서버 B는 각자 유일한 IP 주소인 A,C,B를 각각 가지고 있음

- 호스트 C는 2개의 출발지 포트 번호(26145, 7532)를 자신의 HTTP 연결에 할당
- 호스트 A는 호스트 C와 독립적으로 출발지 포트 번호를 선택하므로, 이것 또한 HTTP 연결에
  출발지 포트로 26145를 할당할 수 있다.

> 이렇게 하더라도 2개의 연결은 다른 출발지 IP 주소를 가지기 때문에 서버 B는 여전히 올바르게
> 역다중화할 수 있다.

웹 서버는 각각의 연결에 따라서 새로운 프로세스를 만든다.  
이들 프로세스는 각자 연결 소켓을 가지며, 이 연결 소켓을 통해 HTTP 요청을 수신하고, HTTP 응답을 전송한다.

그러나 연결 소켓과 프로세스 사이에 항상 일대일 대응이 이루어지는 것은 아니다.

- 오늘날의 많은 고성능 웹 서버는 하나의 프로세스만 사용한다.
- 각각의 새로운 클라이언트 연결을 위해 새로운 연결 소켓과 함께 새로운 스레드를 생성한다.

- `지속적인(persistent) HTTP`: 지속적인 연결의 존속 기간에 클라이언트와 서버는 같은
  서버 소켓을 통해 HTTP 메시지를 교환한다.
- `비지속적인(non-persistent) HTTP`: 모든 요청/응답마다 새로운 TCP 연결이 생성되고 종료된다.
