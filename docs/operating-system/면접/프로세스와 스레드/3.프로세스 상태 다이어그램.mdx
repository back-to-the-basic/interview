---
title: 프로세스 상태 다이어그램을 바탕으로 프로세스의 상태를 설명해주세요.
description: 프로세스 상태 다이어그램
sidebar_position: 3
slug: process-state
---

import Image from '@site/src/components/Image';

프로세스는 실행되면서 그 상태가 변한다. 프로세스의 상태는 부분적으로 그 **프로세스의 현재의 활동에 따라서 정의**된다.

<Image
  src="https://user-images.githubusercontent.com/63354527/218000244-fd30276b-ae03-4748-b249-dc508a8af20c.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/218000244-fd30276b-ae03-4748-b249-dc508a8af20c.png"
  description="Diagram of process state"
/>

<br />

| 상태                  | 설명                                                                                                                        | 작업                                                                                  |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| 생성 상태(new)        | 프로그램을 메모리에 가져와 실행 준비가 완료된 상태이다.                                                                     | 메모리 할당, PCB 생성                                                                 |
| 준비 상태(ready)      | 실행을 기다리는 모든 프로세스가 자기 차례를 기다리는 상태이다. 실행될 프로세스를 CPU 스케줄러가 선택한다.                   | dispatch(PID): 준비 -> 실행                                                           |
| 실행 상태(running)    | 선택된 프로세스가 타임 슬라이스를 얻어 CPU를 사용하는 상태이다. 프로세스 사이의 문맥 교환이 일어난다.                       | timeout(PID): 실행 -> 준비 <br/> exit(PID): 실행 -> 완료<br/>block(PID): 실행 -> 대기 |
| 대기 상태(waiting)    | 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태이다. 입출력이 완료되면 준비 상태로 간다. | wakeup(PID): 대기 -> 준비                                                             |
| 완료 상태(terminated) | 프로세스가 종료된 사앹이다. 사용하던 모든 데이터가 정리된다. 정상 종료인 exit와 비정상 종료인 abort를 포함한다.             | 메모리 삭제, PCB 삭제                                                                 |

## Flow

**생성 상태**는 프로그램이 메모리에 올라오고 운영체제로부터 프로세스 제어 블록을 할당받은 상태이다. 생성된
프로세스는 바로 실행되는 것이 아니라 준비 상태에서 자기 순서를 기다리며, 프로세스 제어 블록도 같이 준비 상태로
옮겨진다.

**준비 상태**는 실행 대기 중인 모든 프로세스가 자기 순서를 기다리는 상태이다. 프로세스 제어 블록은 준비 큐에서 기다리며
CPU 스케줄러에 의해 관리된다.CPU 스케줄러는 준비 상태에서 큐를 몇 개 운영할지, 큐에 있는 어떤 프로세스의 프로세스 제어 블록을
실행 상태로 보낼지를 결정한다.

**실행 상태**는 프로세스가 CPU를 할당받아서 실행되는 상태이다. 준비 상태에 있는 많은 프로세스 중 실행 상태에 들어가는 프로세스는
CPU의 개수 만큼이다. 실행 상태에 있는 프로세스는 자기 자신에게 주어진 시간, 즉 **타임 슬라이스** 동안만 작업할 수 있다. 그러다가
시간을 다 사용하면 timeout(PID)가 실행된다. timeout(PID)는 프로세스 제어 블록을 실행 상태에서 준비 상태로 옮긴다. 만약
실행 상태 동안 작업이 완료되면 exit(PID)가 실행되어 프로세스가 정상 종료된다. 실행 상태에 있는 프로세스가 입출력 요청을 하면
CPU는 입출력 관리자에게 입출력 요청을 하고 block(PID)를 실행한다. block(PID)는 입출력이 완료될 때까지 작업을 진행할 수 없기
때문에 해당 프로세스를 대기 상태로 옮긴다. CPU 스케줄러는 새로운 프로세스를 실행 상태로 가져온다.(dispatch(PID))

**대기 상태**는 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태이다. 대기 상태는 작업의 효율을
위해 만들어진 것으로, 대기 상태의 프로세스는 입출력장치별로 마련된 큐에서 기다린다. 입출력이 완료되면 인터럽트가 발생하고,
대기 상태에 있는 여러 프로세스 중 해당 인터럽트로 깨어날 프로세스를 찾는데 이것이 wakeup(PID)이다. wakeup(PID)로
해당 프로세스의 프로세스 제어 블록이 준비 상태로 이동하게 된다. 어떤 프로세스가 대기 상태에서 준비 상태로 이동하는 것은
인터럽트 때문이다. 인터럽트는 입출력으로 발생하지만 어떤 이벤트에 의해 발생하기도 한다.

**완료 상태**는 프로세스가 종료되는 상태이다. 완료 상태에서는 코드와 사용했던 데이터를 메모리에서 삭제하고 프로세스 제어 블록을
폐기한다. 정상적인 종료는 간단히 exit()으로 처리한다. 만약 오류나 다른 프로세스에 의해 비정상적으로 종료되는 강제 종료(abort)를
만나면 디버깅하기 위해 강제 종료 직전의 메모리 상태를 저장장치로 옮기는데 이를 코어 덤프라고 한다. 코어 덤프는 종료 직전의
메모리 상태를 확인함으로써 오류를 수정할 수 있게 해준다.

## Reference

- 공룡책
- 혼자 공부하는 운영체제
- 쉽게 배우는 운영체제
