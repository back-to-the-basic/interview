---
title: 페이징에 대해서 설명해주세요.
---

import Image from '@site/src/components/Image';

고정 분할 방식으로 메모리를 분할하여 관리하는 페이징 기법에서 가상주소를
물리 주소로 변환하는 방법과 매핑 테이블 관리 방법을 알아보자.

페이징 기법은 고정 분할 방식을 이용한 가상 메모리 관리 기법으로,
물리 주소 공간을 같은 크기로 나누어 사용한다.

아래 그림에서 왼쪽의 가상 주소는 프로세스 입장에서 바라본 메모리 공간으로
항상 0번지부터 시작한다. 가상 주소의 분할된 각 영역은 페이지라고 부르며
첫 번째 영역은 페이지 0, 두번째 영역은 페이지 1과 같이 번호를 매겨 관리한다.

<Image
  src="https://media.vlpt.us/images/chappi/post/18f268bd-8da3-492a-b672-4f942a138294/3.png"
  width="800px"
/>

물리 메모리의 각 영역은 가상 주소의 페이지와 구분하기 위해 프레임이라고 부른다.
프레임도 페이지와 마찬가지로 번호를 매겨서 관리하고 이 둘의 크기는 같다.

위의 그림은 가상 주소의 각 페이지가 물리 메모리의 어디에 위치하는지를 나타낸다.
페이지와 프레임은 크기가 같기 때문에 어떤 프레임에도 배치될 수 있다.
이에 대한 맵핑 정보는 페이지 테이블에 담겨져있다.

페이지 테이블은 하나의 열(column)으로 구성된다.
모든 페이지의 정보를 순서대로 가지고 있기 때문에 위에서부터
차례대로 페이지 0, 페이지1, 페이지2와 같은 프레임 번호를 가지고 있어
추가 열이 필요없다. 그런데 페이지 테이블에는 숫자만 있는 것이 아니다.

페이지 5는 물리 메모리에 없기 때문에 페이지 테이블에 invalid라고
표시되어있다. invalid는 해당 페이지가 스왑 영역에 있다는 의미이다.

## 페이징 기법의 주소 변환

아래 그림은 페이징 기법에서 가상 주소가 물리 주소로 어떻게 변환되는지 보여준다.

<Image
  src="https://media.vlpt.us/images/chappi/post/e86d6063-3a61-470c-9473-d4211e091a5e/4.png"
  width="800px"
/>

메모리는 1Byte 기준으로 작성된다. 페이지와 프레임의 각 크기를 10byte로 잡아놓으면,
총 10개의 주소를 저장할 수 있다. 즉, 페이지 0에는 0~9번지의 10개의 주소가 있고,
페이지 1에는 10~19번지의 10개의 주소가 있다. 물리 주소 공간도 마찬가지로 각
프레임에 10개의 주소가 있다.

가상 주소를 물리 주소로 변환하는 과정을 살펴보자. 프로세스가 30번지의 내용을
읽으려고 할 때의 주소 변환 과정은 다음과 같다.

1. 가상 주소 30번지가 어느 페이지에 있는지 찾는다. 페이지 3의 0번째 위치에 있다.
2. 페이지 테이블의 페이지 3으로 가서 해당 페이지가 프레임 1에 있다는 것을 알아낸다.
3. 물리 메모리 프레임 1의 0번째 위치에 접근한다. 이 주소가 가상 주소 30번지의 물리 주소이다.

## 페이지 교체(Page Replacement)

원하는 페이지가 물리 메모리에 존재하지 않으면 어쩔 수 없이 어떤 페이지는 내려놔야 한다.
원하는 페이지가 물리 메모리에 없으면 페이지 폴트(Page fault)가 일어났다고 하고, 물리 메모리에서
내려갈 페이지를 Victim이라고 한다. Victim을 선택하는 알고리즘은 여러가지가 있다.

## Reference

- 쉽게 배우는 운영체제
