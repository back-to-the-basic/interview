---
title: 프로세스
---

import Image from '@site/src/components/Image';

초기의 컴퓨터 시스템은 한 번에 하나의 프로그램만을 실행하도록 허용하였다. 이 프로그램이 시스템을 완전히
제어하고, 시스템의 모든 자원에 접근할 수 있었다. 반면 오늘날의 컴퓨터 시스템들은 메모리에
다수의 프로그램이 적재되어 병행 실행되는 것을 허용한다. 이러한 발전은 다양한 프로그램을 보다
견고하게 제어하고 보다 구획화할 것을 필요로 했다. 이러한 필요성이 프로세스의 개념을 낳았으며,
프로세스란 실행 중인 프로그램을 말한다. 프로세스는 현대의 컴퓨팅 시스템에서 작업의 단위이다.

운영체제가 더욱 복잡해질수록, 사용자를 위해 더 많은 기능이 기대된다. 비록 운영체제의 주 관심은
사용자 프로그램을 실행하는 것이지만, 또한 운영체제는 커널 안에서 보다 사용자 공간에서 가장
잘 할 수 있는 다양한 시스템 작업을 처리할 필요가 있다. 그러므로 하나의 시스템의 일부는
사용자 코드를 실행하고 일부는 운영체제 코드를 실행하는 프로세스의 집합체이다. 이들 모든
프로세스는 잠재적으로 병행 실행이 가능하고, CPU는 이들 프로세스 가운데서 다중화(multiplex)
된다.

## 프로세스 개념

초창기 컴퓨터는 작업을 실행하는 일괄처리 시스템이었고, 사용자 프로그램 또는 태스크(task)를
실행하는 시분할 시스템이 뒤를 이었다. 단일 사용자 시스템에서도 사용자는 워드 프로세서, 웹
브라우저 및 전자 메일 패키지와 같은 여러 프로그램을 한 번에 실행할 수 있다. 또한 다중 태스킹을
지원하지 않는 임베디드 장치에서와 같이 컴퓨터가 한 번에 하나의 프로그램만 실행할 수 있더라도
운영체제는 메모리 관리와 같은 자체 프로그램된 내부 활동을 지원해야 할 수도 있다. 여러 측면에서
이러한 모든 활동을 프로세스라고 부를 수 있다.

### 프로세스

비공식적으로, 프로세스란 실행 중인 프로그램이다. 프로세스의 현재 활동의 상태는 프로그램 카운터
값과 프로세서 레지스터의 내용으로 나타낸다. 프로세스의메모리 배치는 일반적으로 여러 섹션으로
구분되며 아래와 같다.

<Image
  src="https://user-images.githubusercontent.com/63354527/217720856-013fa9d7-5335-456a-a2f5-84a0900572b4.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/217720856-013fa9d7-5335-456a-a2f5-84a0900572b4.png"
  description="프로세스 메모리 배치"
/>

<br />

- 텍스트 섹션: 실행 코드
- 데이터 섹션: 전역 변수
- 힙 섹션: 프로그램 실행 중에 동적으로 할당되는 메모리
- 스택 섹션: 함수를 호출할 때 임시 데이터 저장장소(예: 함수 매개변수, 복귀 주소 및 지역 변수)

텍스트 및 데이터 섹션의 크기는 고정되기 때문에 프로그램 실행 시간 동안 크기가 변하지 않는다. 그러나
스택 및 힙 섹션은 프로그램 실행 중에 동적으로 줄어들거나 커질 수 있다. 함수가 호출될 때마다 함수 매개변수,
지역 변수 및 복귀 주소를 포함하는 활성화 레코드(activation record)가 스택에 푸쉬된다. 함수에서 제어가
되돌아오면 스택에서 활성화 레코드가 팝된다. 마찬가지롬 메모리가 동적으로 할당됨에 따라 힙이 커지고 메모리가
시스템에 반환되면 축소된다. 스택 및 힙 섹션이 서로의 방햐응로 커지더라도 운영체제는 서로 겹치지 않도록
해야한다.

우리는 프로그램 그 자체는 프로세스가 아님을 강조한다. 프로그램은 명령어 리스트를 내용으로 가진 디스크에 저장된
파일(실행 파일이라고 불림)과 같은 수동적인 존재(passive entity)이다. 이와 대조적으로 프로세스는 다음에
실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 능동적인 존재(active entity)이다.
실행 파일이 메모리에 적재될 때 프로그램은 프로세스가 된다. 실행 파일을 메모리에 적재하는 일반적인 두 가지
방식은 실행 파일을 나타내는 아이콘을 더블 클릭하는 방식과 명령어 라인상에서 prog.exe 또는 a.out과 같이
파일 이름을 입력하는 방식이다.

두 프로세스들이 동일한 프로그램에 연관될 수 있지만, 이들은 두 개의 별도의 실행 순서로 간주한다. 예를 들어,
여러 사용자가 메일 프로그램의 서로 다른 복사본을 실행하거나, 또는 동일 사용자가 웹 브라우저 프로그램의 여러
복사본을 호출할 수 있다. 이들 각각은 별도의 프로세스이며, 텍스트 섹션이 동등하다 할지라도 데이터, 힙 및 스택
섹션은 다를 수 있다.

프로세스 자체가 다른 개체를 위한 실행 환경으로 동작할 수 있다는 사실에 주목하십시오. Java 프로그래밍 환경이
좋은 예를 보인다. 대부분의 상황에서 실행 가능한 Java 프로그램은 Java 가상 기계(JVM)안에서 실행된다.
JVM은 적재된 Java 코드를 해석하고 그 코드를 대신하여 원 기계어를 이용하는 행동을 취하는 프로세스로서
프로그램을 실행한다.

### 프로세스의 상태

프로세스는 실행되면서 그 상태가 변한다. 프로세스의 상태는 부분적으로 그 프로세스의 현재의 활동에 따라서 정의된다.

<Image
  width="500px"
  src="https://user-images.githubusercontent.com/63354527/218000244-fd30276b-ae03-4748-b249-dc508a8af20c.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/218000244-fd30276b-ae03-4748-b249-dc508a8af20c.png"
  description="Diagram of process state"
/>

- new: 프로세스가 생성 중이다.
- running: 명령어들이 실행되고 있다.
- waiting: 프로세스가 어떤 이벤트(입출력 완료 또는 신호의 수신 같은)가 일어나기를 기다린다.
- ready: 프로세스가 처리기에 할당되기를 기다린다.
- terminated: 프로세스의 실행이 종료되었다.

### 프로세스 제어 블록

각 프로세스는 운영체제에서 프로세스 제어 블록에 의해 표현된다.
프로세스 제어 블록은 특정 프로세스와 연관된 여러 정보를 수록하며 다음과 같은 것들을
포함한다.

- 프로세스 상태: 상태는 new, ready, running, waiting 또는 halted 상태 등이다.
- 프로그램 카운터: 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.
- CPU 레지스터들: CPU 레지스터는 컴퓨터의 구조에 따라 다양한 수와 유형을 가진다.
  레지스터에는 누산기(accumulator), 인덱스 레지스터, 스택 레지스터, 범용(general purpose)
  레지스터들과 상태 코드(condition code) 정보가 포함된다. 프로그램 카운터와 함께
  이 상태 정보는, 나중에 프로세스가 다시 스케줄 될 때 계속 올바르게 실행되도록
  하기 위해서 인터럽트 발생시 저장되어야 한다.
- CPU 스케줄링 정보: 이 정보는 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른
  스케줄 매개변수를 포함한다.
- 메모리 관리 정보: 운영체제에 의해 사용되는 메모리 시스템에 따라 base 레지스터와
  한계(limit) 레지스터의 값, 운영체제가 사용하는 메모리 시스템에 따라 페이지 테이블 또는
  세그먼트 테이블 등과 같은 정보를 포함한다.
- 회계 정보: CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 잡 또는 프로세스 번호등을 포함한다.
- 입출력 상태 정보: 프로세스에 의해 할당된 입출력 장치들과 열린 파일의 목록등을 포함한다.

요약하면 **PCB는 약간의 회계 데이터와 함께 프로세스를 시작시키거나 다시 시작시키는데 필요한 모든 데이터를
위한 저장소의 역할**을 한다.

### 스레드

대부분의 현대 운영체제는 프로세스 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다.
그들은 따라서 프로세스가 한 번에 하나 이상의 일을 수행할 수 있도록 허용한다.
이러한 특성은 특히 다중 처리기 시스템에서 이익을 얻을 수 있는데, 여러 스레드가 병렬로 실행가능하다.

예를 들어 다중 스레드 워드 프로세서는 하나의 스레드에 사용자 입력 관리를 맡기는 동안
다른 스레드에서 철자 검사기를 수행하도록 만들 수 있다.

스레드를 지원하는 시스템에서는 PCB는 각 스레드에 관한 정보를 포함하도록 확장된다.

## 프로세스 스케줄링

**다중 프로그래밍의 목적은 CPU 이용을 최대화하기 위하여 항상 어떤 프로세스가 실행되도록
하는데 있다.** 시분할의 목적은 각 프로그램이 실행되는 동안 사용자가 상호작용할 수 있도록
프로세스들 사이에서 CPU 코어를 빈번하게 교체하는 것이다.

이 목적을 달성하기 위해 프로세스 스케줄러는 코어에서 실행 가능한 여러 프로세스 중에서 하나의
프로세스를 선택한다. 각 CPU 코어는 한 번에 하나의 프로세스를 실행할 수 있다. 단일 CPU
코어가 있는 시스템의 경우 한 번에 2개 이상의 프로세스가 실행될 수 없지만 다중 코어 시스템은
한 번에 여러 프로세스를 실행할 수 있다. 코어보다 많은 프로세스가 있는 경우 초과 프로세스는
코어가 사용이 가능해지고 다시 스케줄 될 때까지 기다려야 한다.

현재 메모리에 있는 프로세스 수를 다중 프로그래밍 정도라고 한다. 다중 프로그래밍 및 시간
공유의 목표를 균형 있게 유지하려면 프로세스의 일반적인 동작을 고려해야 한다.
일반적으로 대부분의 프로세스는 I/O 바운드 또는 CPU 바운드로 설명할 수 있다.
`I/O 바운드 프로세스`는 계산에 소비하는 것보다 I/O에 더 많은 시간을 소비하는 프로세스이다.
반대로 `CPU 바운드 프로세스`는 계산에 더 많은 시간을 사용하여 I/O 요청을 자주 생성하지 않는다.

### 3.2.1 스케줄링 큐

프로세스가 시스템에 들어가면 준비 큐에 들어가서 준비 상태가 되어 CPU 코어에서 실행되기를
기다린다. 이 큐는 일반적으로 연결 리스트로 저장된다. 준비 큐 헤더에는 리스트의 첫 번째
PCB에 대한 포인터가 저장되고 각 PCB에는 준비 큐의 다음 PCB를 가리키는 포인터 필드가 포함된다.

시스템에는 다른 큐도 존재한다. 프로세스에 CPU 코어가 할당되면 프로세스는 잠시 동안
실행되어 결국 종료되거나 인터럽트 되거나 I/O 요청의 완료와 같은 특정 이벤트가 발생할 때까지
기다린다. 프로세스가 디스크와 같은 장치에 I/O 요청을 한다고 가정하자. 장치는 프로세서보다
상당히 느리게 실행되므로 프로세스는 I/O가 사용 가능할 때까지 기다려야 한다. I/O 완료와 같은
특정 이벤트가 발생하기를 기다리는 프로세스는 대기 큐에 삽입된다.

프로세스 스케줄링의 일반적인 표현은 아래와 같은 큐잉 다이어그램이다. 준비 큐와 대기 큐 집합의
두 가지 유형의 큐가 제시되어 있다. 원은 큐에 서비스를 제공하는 자원을 나타내고 화살표는
시스템의 프로세스의 흐름을 나타낸다.

<Image
  width="500px"
  src="https://github.com/back-to-the-basic/interview/assets/63354527/ca9769c6-2e80-4c69-b289-b983639fcf41"
/>

- 프로세스가 I/O 요청을 공표한 다음 I/O 대기 큐에 놓일 수 있다.
- 프로세스는 새 자식 프로세스를 만든 다음 자식의 종료를 기다리는 동안 대기 큐에 놓일 수 있다.
- 인터럽트 또는 타임 슬라이스가 만료되어 프로세스가 코어에서 강제로 제거되어 준비 큐로 들어갈 수도 있다.

### 스케줄링

프로세스는 수명 주기 동안 준비 큐와 대기 큐를 이주한다. CPU 스케줄러의 역할은 준비 큐에 있는
프로세스 중에서 선택된 하나의 프로세스에 CPU 코어를 할당하는 것이다.

일부 운영체제는 스와핑으로 알려진 중간 형태의 스케줄링 알고리즘을 가지고 있는데, 핵심 아이디어는
때로는 메모리에서(및 CPU에 대한 능동적 경쟁에서) 프로세스를 제거하여 다중 프로그래밍 정도를
감소시키는 것이 유리할 수 있다는 것이다. 나중에 프로세스를 메모리에 다시 적재될 수 있으며 중단된
위치에서 실행을 계속할 수 있다. 프로세스를 메모리에서 디스크로 "스왑 아웃"하고 현재 상태를 저장하고,
이후 디스크에서 메모리로 "스왑 인"하여 상태를 복원할 수 있기 때문에 이 기법을 `스와핑`이라고 한다.
스와핑은 일반적으로 메모리가 초과 사용되어 가용공간을 확보해야 할 때만 필요하다.

### 문맥 교환

CPU 코어를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를
복구하는 작업이 필요하다. 이 작업을 문맥 교환(context switch)이라고 한다. 문맥 교환이 일어나면, 커널은
과거 프로세스의 문맥을 PCB에 저장하고, 실행이 스케줄된 새로운 프로세스의 저장된 문맥을 복구한다.

문맥 교환이 진행될 동안 시스템이 아무런 유용한 일을 못하기 대문에 문맥 교환 시간은 순수한 오버헤드다.
교환 속도는 메모리의 속도, 반드시 복사되어야 하는 레지스터의 수, 특수 명령어(모든 레지스터를 하나의 명령어로
보관하고 적재하는 것과 같은)의 존재에 좌우되므로, 기계마다 다르다.

문맥교환의 시간은 하드웨어의 지원에 크게 좌우된다.
예를 들어, 일부 처리기들은 여러 개의 레지스터 집합을 제공한다. 문맥 교환은 단순히 현행 레지스터 집합에
대한 포인터를 변경하는 것을 포함한다.

운영체제가 복잡할수록, 문맥 교환 시 해야 할 작업의 양이 더 많아진다. 복잡한 고급 메모리 관리 기법을 사용하면
문맥 교환 시 더 많은 자료를 교환해야 한다. 예를 들어, 문맥 교환 시 현재 프로세스의 주소 공간은 다음 태스크의
공간이 사용 준비되는 동안 반드시 보존되어야 한다. 주소 공간이 어떤 식으로 보존되고, 보존하기 위해 수행해야 할
작업의 양은 운영체제의 메모리 관리 기법에 따라 달라진다.

## 프로세스에 대한 연산

대부분 시스템 내의 프로세스들은 병행 실행될 수 있으며, 반드시 동적으로 생성되고, 제거되어야 한다.
그러므로 운영체제는 프로세스 생성 및 종료를 위한 기법을 제공해야 한다.

### 프로세스 생성
