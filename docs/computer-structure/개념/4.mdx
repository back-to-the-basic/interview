---
sidebar_position: 4
title: CPU의 작동 원리
description: CPU의 작동 원리에 대해 알아보자
tags:
  - ALU
  - 플래그
  - 제어장치
  - 레지스터
  - 명령어 사이클
  - 인터럽트
---


export const Image = ({ src, size }) => {
  return (
    <>
      <img
        src={src}
        width={size}
        height={size}
        style={{
          display: "block",
          margin: "auto",
        }}
      />
      <br />
    </>
  );
};

### ALU와 제어장치

<Image
  src="https://user-images.githubusercontent.com/64428916/210801539-b049a386-9415-4757-8ef5-7e1321d6aac7.png"
  size="800"
/>

- ALU: 레지스터로부터 피연산자를 받아들이고, 제어장치로부터 제어 신호를 받아들인다.
- ALU는 연산 결과와 플래그를 내보낸다.
- 플래그: 연산 결과에 대한 추가적인 상태 정보
    - 부호 플래그: 연산한 결과의 부호를 나타낸다.
    - 제로 플래그: 연산 결과가 0인지 여부를 나타낸다.
    - 캐리 플래그: 연산 결과 올림수나 빌림수가 발생했는지를 나타낸다.
    - 오버플로우 플래그: 오버플로우가 발생했는지를 나타낸다.
    - 인터럽트 플래그: 인터럽트가 가능한지를 나타낸다.
    - 슈퍼바이저 플래그: 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타낸다.

<Image
  src="https://user-images.githubusercontent.com/64428916/210801528-2c412e22-eb2d-423a-bad7-3c92a04b8eac.png"
  size="900"
/>


- 제어장치: 클럭, 현재 수행할 명령어, 플래그, 제어 신호를 받아들인다.
    - 클럭: 컴퓨터의 모든 부품을 움직일 수 있게 하는 시간 단위
    - CPU가 해석해야할 명령어는 명령어 레지스터라는 특별한 레지스터에 저장된다.
    - 플래그는 ALU연산에 대한 추가적인 상태 정보이다. 제어장치가 제어 신호를 통해 컴퓨터 부품들을 제어할 때 이 중요한 참고 사항을 무시하면 안된다.
    - 제어 신호는 CPU뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있다. 제어 장치는 에저 버스를 통해 외부로부터 전달된 제어 신호를 받아들이기도 한다.
- 제어 신호: 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호
- 제어장치는 CPU 내부와 외부로 제어 신호를 내보낸다.

### 레지스터


- **프로그램 카운터**: 메모리에서 읽어 들일 명령어의 주소를 저장한다. 명령어 포인터라고 부르는 CPU도 있다.
- **명령어 레지스터**: 방금 메모리에서 읽어 들인 명령어를 저장한다. 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보낸다.
- **메모리 주소 레지스터**: 메모리의 주소를 저장한다. CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거친다.
- **메모리 버퍼 레지스터**: 메모리와 주고받을 값(데이터, 명령어)을 저장한다. 데이터 버스로 주고받을 값은 메모리 버퍼 레지스터를 거친다.
- **범용 레지스터**: 데이터와 주소를 모두 저장할 수 있다.
- **플래그 레지스터**: 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장한다.
- 스택 주소 지정 방식: 스택과 스택 포인터를 이용한 주소 지정 방식
    
    **스택 포인터**: 스택의 꼭대기를 가리키는 레지스터
    
- 변위 주소 지정 방식: 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식
    
    → 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 상대 주소 지정 방식, 베이스 레지스터 주소 지정 방식 등으로 나뉜다.
    
    1) **상대 주소 지정 방식**: 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
    
    2) **베이스 레지스터 주소 지정 방식**: 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식
    

### 명령어 사이클과 인터럽트

<Image
  src="https://user-images.githubusercontent.com/64428916/210801516-499e2661-13ce-4dca-bbc7-d1462ddb37bc.png"
  size="700"
/>



- **명령어 사이클**: 하나의 명령어가 처리되는 주기, 인출, 실행, 간접, 인터럽트 사이클로 구성되어 있다.
  - 실행 사이클: CPU로 가져온 명령어를 실행하는 단계, 제어장치가 명령어 레지스터에 담긴 값을 해석하고 제어 신호를 발생시키는 단계이다.
- **인터럽트**:  CPU의 정상적인 작업을 방해하는 신호
    - 동기 인터럽트(**예외**): CPU에 의해 발생하는 인터럽트 <br/>
    ex) CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생
        
    - 비동기 인터럽트(**하드웨어 인터럽트**): 주로 입출력장치에 의해 발생하는 인터럽트 <br/>
    → 하드웨어 인터럽트를 사용하면 CPU는 완료 인터럽트를 받을 때까지 다른 작업을 처리할 수 있다.
        
- 하드웨어 인터럽트 처리 순서<br/>
    1) 입출력장치는 CPU에 인터럽트 요청 신호를 보낸다.   
    2) CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.  
    3) CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.            
    4) 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.        
    5) CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다.  
    6) 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개한다.


- 인터럽트 서비스 루틴: 인터럽트를 처리하기 위한 동작들로 이루어진 프로그램, 어떻게 처리하고 작동해야 할지에 대한 정보를 알 수있다.


:::tip 인터럽트 요청 신호

CPU의 작업을 방해하는 인터럽트에 대한 요청
    
:::

:::tip 인터럽트 플래그

인터럽트 요청 신호를 받아들일지 무시할지 결정하는 비트

:::

:::tip 인터럽트 벡터

인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보

:::