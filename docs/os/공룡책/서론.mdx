import Image from '@site/src/components/Image';

# 서론

**운영체제(Operating System)**는 컴퓨터 하드웨어를 관리하는 소프트웨어이다. 운영체제는
응용 프로그램을 위한 기반을 제공하며 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 한다.

운영체제의 목적은 사용자가 프로그램을 편리하고 효율적으로 수행할 수 있는 환경을
제공하는데 있다.

<Image
  src="https://user-images.githubusercontent.com/63354527/211204342-9d3ec1e1-1de6-4f34-a189-ef8e576e8bf6.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211204342-9d3ec1e1-1de6-4f34-a189-ef8e576e8bf6.png"
  description="운영체제의 계층적 위치"
  width="400px"
/>

<br />

## 운영체제가 할 일(What Operating Systems Do)

컴퓨터 시스템은 대게 네 가지 구성요소인 하드웨어, 운영체제, 응용 프로그램 및 사용자로 구분할 수 있다.
하드웨어는 `중앙 처리 장치(CPU)`, `메모리 및 입출력(I/O) 장치`로 구성되어,기본 계산용 자원을 제공한다.
운영체제는 다양한 사용자를 위해 다양한 응용 프로그램 간의 하드웨어 사용을 제어하고 조정한다.

컴퓨터 시스템은 하드웨어, 소프트웨어 및 데이터로 구성되어 있다고 볼 수 있다. 운영체제는 컴퓨터 시스템이
동작할 때 이들 자원을 적절하게 사용할 수 있는 방법을 제공한다.

운영체제의 역할을 좀 더 완전히 이해하기 위해 사용자 관점과 시스템 관점에서 살펴볼 수 있다.

### 사용자 관점(User View)

컴퓨터를 사용하는데 있어서 사용자 관점에서의 목표는 **손쉬운 사용**이다. 많은 컴퓨터 사용자는 랩톱 혹은 모니터,
키보드, 마우스로 구성된 PC 앞에서 작업한다. 이러한 시스템은 한 사용자가 자원을 독점하도록 설계되었으며
목표는 사용자가 수행하는 작업을 최대화하는 것이다. 다양한 하드웨어와 소프트웨어 자원이 어떻게 공유되느냐의
**자원의 이용(Resource Utilization)**에는 전혀 신경을 쓰지 않는다.

### 시스템 관점(System View)

컴퓨터 관점에서 운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램이다. 따라서 우리는 운영체제를
**자원 할당자(Resource Allocator)**로 볼 수 있다. 컴퓨터 시스템은 문제를 해결하기 위해
요구되는 여러 가지 자원들(하드웨어와 소프트웨어), 즉 CPU 시간, 메모리 공간, 저장장치 공간,
입출력 장치등을 가진다. 운영체제는 이들 자원의 관리자로서 동작한다. 자원에 대해 서로 상충할 수도 있는
많은 요청이 있으므로, 운영체제는 컴퓨터 시스템을 효율적이고 공정하게 운영할 수 있도록 어느 요청에
자원을 할당할지 결정해야 한다.

운영체제는 여러가지 입출력 장치와 사용자 프로그램을 제어해야한다. 따라서 운영체제는
**제어 프로그램(Control Program)**이다. 제어 프로그램은 컴퓨터의 부적절한 사용을 방지하기 위해
사용자 프로그램의 수행을 제어한다. 운영체제는 특히 입출력 장치의 제어와 작동에 깊게 관여한다.

### 운영체제의 정의

일반적으로 운영체제에 대한 적합한 정의는 없다. 운영체제는 유용한 컴퓨팅 시스템을 만드는 문제를
해결할 수 있는 합리적인 방법을 제공하기 때문에 존재한다. **컴퓨터 시스템의 기본 목표는 프로그램을
실행하고 사용자 문제를 더욱 쉽게 해결할 수 있게 하는 것이다.** 컴퓨터 하드웨어는 이 목표를
가지고 구성된다. 오로지 하드웨어만으로는 사용하기가 쉽지 않으므로 응용 프로그램이 개발된다.
이러한 프로그램에는 입출력 장치 제어와 같은 특정 공통 작업이 필요하다. 자원을 제어하고 할당하는
일반적인 기능은 운영체제라는 하나의 소프트웨어로 통합된다.

운영체제는 컴퓨터에서 항상 실행되는 프로그램(일반적으로 `커널`이라고 함)이다. 커널과 함께
두 가지 다른 유형의 프로그램이 있다. 운영체제와 관련되어 있지만 반드시 커널의 일부일 필요는 없는
**시스템 프로그램**과 시스템 작동과 관련되지 않은 모든 프로그램을 포함하는 **응용 프로그램**이다.

## 컴퓨터 시스템의 구성(Computer System Organization)

현대의 범용 컴퓨터 시스템은 하나 이상의 CPU와 구성요소와 공유 메모리 사이의 엑세스를 제공하는 공통
**버스**를 통해 연결된 여러 장치 컨트롤러로 구성된다.

일반적으로 운영체제는 각 장치 컨트롤러마다 **장치 드라이버**가 있다. 이 장치 드라이버는 장치
컨트롤러의 작동을 잘 알고 있고 나머지 운영체제 장치에 대한 일관된 인터페이스를 제공한다.
CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다. 공유 메모리를 질서 있게
엑세스하기 위해 메모리 컨트롤러는 메모리에 대한 엑세스를 동기화한다.

<Image
  src="https://user-images.githubusercontent.com/63354527/211206564-07a8b409-d8d7-4b0b-923a-33179f65c452.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211206564-07a8b409-d8d7-4b0b-923a-33179f65c452.png"
  description="통상적인 PC 컴퓨터 시스템"
/>

### 인터럽트(Interrupts)

하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다.
(컴퓨터 시스템에는 많은 버스가 있을 수 있지만 시스템 버스는 주요 구성요소 사이의 주요 통신 경로디.)
인터럽트는 다른 많은 목적으로도 사용되며 운영체제와 하드웨어의 상호 작용 방식의 핵심 부분이다.

CPU가 인터럽트 되면, CPU는 하던 일을 중단하고 즉시 고정된 위치로 실행을 옮긴다. 이러한 고정된 위치는
일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있다. 그리고 인터럽트 서비스 루틴이
실행된다. **인터럽트 서비스 루틴의 실행이 완료되면, CPU는 인터럽트 되었던 연산을 재개한다.**

각 컴퓨터 설계는 자신의 인터럽트 메커니즘을 가지고 있으며, 몇 가지 기능은 공통적이다.
인터럽트는 적절한 서비스 루틴으로 제어를 전달한다. 이러한 전달을 관리하는 직선적인 방법은 인터럽트 정보를
조사하는 일반적인 루틴을 호출하는 방법이다. 이 루틴은 이어 인터럽트 고유의 핸들러(handler)를 호출한다.
그러나, 인터럽트는 매우 빈번하게 발생하기 때문에 빠르게 처리되어야 한다. 필요한 속도를 제공하기 위해
인터럽트 서비스 루틴에 대한 포인터들의 테이블을 대신 이용할 수 있다. 이 경우 중간 루틴을 돌 필요 없이,
테이블을 통하여 간접적으로 인터럽트 루틴이 호출될 수 있다. 일반적으로 포인터들의 테이블은 하위 메모리에
저장된다. 이들 위치에서는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어있다.
인터럽트가 요청되면, 인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해
이 주소의 배열, 즉 `인터럽트 벡터`가 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인된다.

<Image
  src="https://user-images.githubusercontent.com/63354527/211700046-2984ef43-500c-4533-b99a-56bd4e1efd65.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211700046-2984ef43-500c-4533-b99a-56bd4e1efd65.png"
  description="출력을 수행하고 있는 단일 프로세스에 대한 인터럽트 시간 일정"
/>

<br />

인터럽트 구조는 또한 인터럽트된 모든 정보를 저장해야 인터럽트를 처리한 후 이 정보를 복원할 수 있다.
만약 만약 인터럽트 루틴이 처리기의 상태를 변경할 필요(예를 들어 레지스터의 값을 변경하여)가 있다면,
인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장하여야 하며, 복귀하기 전에 상태를 복원해야 한다.
인터럽트를 서비스한 후, 저장되어 있던 복귀 주소를 프로그램 카운터에 적재하고, 인터럽트에 의해
중단되었던 연산이 인터럽트가 발생되지 않았던 것처럼 다시 시작된다.

#### 구현(Implementation)

CPU 하드웨어는 `인터럽트 요청 라인(interrupt request line)`이라는 선이 있는데, 하나의 명령어의
실행을 완료할 때마다 CPU가 이 선을 감지한다. CPU가 컨트롤러가 인터럽트 요청 라인에 신호를 보낸 것을
감지하면, 인터럽트 번호를 읽고 이 번호를 인터럽트 벡터의 인덱스로 사용하여
`인터럽트 핸들러 루틴(interrupt-handler routine)`으로 점프한다. 그런 다음 해당 인덱스와 관련된
주소에서 실행을 시작한다. 인터럽트 처리기는 작업 중에 변경될 상태를 저장하고, 언터럽트 원인을 확인하고,
필요한 처리를 수행하고, 상태 복원을 수행하고, return_from_interrupt 명령어를 실행하여 CPU를
인터럽트 전 실행 상태로 되돌린다. 장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트를
발생시키고 CPU는 인터럽트를 포착(catch)하여 인터럽트 핸들러로 디스패치(dipatch)하고 핸들러는
장치를 서비스하여 인터럽트를 지운다(clear).

<Image
  src="https://user-images.githubusercontent.com/63354527/211702248-741e139c-6988-455c-bcb8-6d3a033d2e20.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211702248-741e139c-6988-455c-bcb8-6d3a033d2e20.png"
  description="인터럽트-구동 방식의 입출력 사이클"
/>

<br />

최신 운영체제에서는 더욱 정교한 인터럽트 처리 기능이 필요하다.

1. 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 한다.
2. 장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법이 필요하다.
3. 운영체제가 우선순위가 높은 인터럽트와 우선순위가 낮은 인터럽트를 구분하고 적절한 긴급도로 대응할 수
   있도록 다단계 인터럽트가 필요하다.

최신 컴퓨터 하드웨어에서 이 세가지 기능은 CPU 및 `인터럽트 컨트롤러 하드웨어`에 의해 제공된다.

대부분의 CPU에는 2개의 인터럽트 요청 라인이 있다. 하나는 복구할 수 없는 메모리 오류와 같은 이벤트를
위해 예약된 `마스크 불가능 인터럽트`(nonmaskable interrupt)이다. 두 번째 인터럽트 라인은
`마스킹 가능`(maskable)이다. 인터럽트 되어서는 안되는 ㅈ둥요한 명령 시퀀스를 싱행하기 전에 CPU에 의해
꺼질 수 있다.

벡터 방식 인터럽트 기법의 목적은 서비스가 필요한 장치를 결정하기 위해 하나의 인터럽트 핸들러가 가능한
모든 인터럽트 소스를 검색할 필요를 줄이기 위한 것이다. 그러나 실제로 컴퓨터에는 인터럽트 벡터의 주소
개수보다 많은 장치가 있다. 이 문제를 해결하는 일반적인 방법은 `인터럽트 체인`을 사용하는 것이다.
인터럽트 벡터의 각 원소는 인터럽트 핸들러 리스트의 헤드를 가리킨다. 인터럽트가 발생하면 요청을
처리할 수 있는 핸들러가 발견될 때까지 상응하는 리스트의 핸들러가 하나씩 호출된다. 이러한 구조는
큰 크기의 인터럽트 테이블의 오버헤드와 하나의 인터럽트 핸들러로 디스패치 하는 비효율성의 절충안이다.

<Image
  width="400px"
  src="https://user-images.githubusercontent.com/63354527/211706225-f5d6a9a8-662b-4545-8047-57cca7a1454c.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211706225-f5d6a9a8-662b-4545-8047-57cca7a1454c.png"
  description="Intel 처리기 이벤트-벡터 테이블"
/>

위 사진은 인텔 프로세스의 인터럽트 벡터 설계를 보여준다. 마스크 불가능한 0에서 31까지의 이벤트는 다양한
오류 조건을 알리는데 사용된다. 마스크 가능한 32에서 255까지의 이벤트는 장치가 생성한 인터럽트 같은
그 외 인터럽트를 처리하기 위해서 사용된다.

인터럽트 기법은 또한 인터럽트 우선순위 레벨(interrupt priority level)을 구현한다. 이러한 레벨을
통해 CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위가 낮은 인터럽트 처리를 연기할 수 있고, 우선순위가
높은 인터럽트가 우선순위가 낮은 인터럽트의 실행을 선점할 수 있다.

요약하면, 인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 위해 사용된다. 장치 컨트롤러 및 하드웨어
오류로 인해 인터럽트가 발생한다. 가장 긴급한 작업을 먼저 수행하기 위해 최신 컴퓨터는 인터럽트 우선순위
시스템을 사용한다. 인터럽트는 시간에 민감한 처리에 빈번하게 사용되므로 시스템 성능을 좋게 하려면
효율적인 인터럽트 처리가 필요하다.

## Reference

- Operating System Concepts(공룡책)
