import Image from '@site/src/components/Image';

# 서론

**운영체제(Operating System)**는 컴퓨터 하드웨어를 관리하는 소프트웨어이다. 운영체제는
응용 프로그램을 위한 기반을 제공하며 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 한다.

운영체제의 목적은 사용자가 프로그램을 편리하고 효율적으로 수행할 수 있는 환경을
제공하는데 있다.

<Image
  src="https://user-images.githubusercontent.com/63354527/211204342-9d3ec1e1-1de6-4f34-a189-ef8e576e8bf6.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211204342-9d3ec1e1-1de6-4f34-a189-ef8e576e8bf6.png"
  description="운영체제의 계층적 위치"
  width="400px"
/>

<br />

## 운영체제가 할 일(What Operating Systems Do)

컴퓨터 시스템은 대게 네 가지 구성요소인 하드웨어, 운영체제, 응용 프로그램 및 사용자로 구분할 수 있다.
하드웨어는 `중앙 처리 장치(CPU)`, `메모리 및 입출력(I/O) 장치`로 구성되어,기본 계산용 자원을 제공한다.
운영체제는 다양한 사용자를 위해 다양한 응용 프로그램 간의 하드웨어 사용을 제어하고 조정한다.

컴퓨터 시스템은 하드웨어, 소프트웨어 및 데이터로 구성되어 있다고 볼 수 있다. 운영체제는 컴퓨터 시스템이
동작할 때 이들 자원을 적절하게 사용할 수 있는 방법을 제공한다.

운영체제의 역할을 좀 더 완전히 이해하기 위해 사용자 관점과 시스템 관점에서 살펴볼 수 있다.

### 사용자 관점(User View)

컴퓨터를 사용하는데 있어서 사용자 관점에서의 목표는 **손쉬운 사용**이다. 많은 컴퓨터 사용자는 랩톱 혹은 모니터,
키보드, 마우스로 구성된 PC 앞에서 작업한다. 이러한 시스템은 한 사용자가 자원을 독점하도록 설계되었으며
목표는 사용자가 수행하는 작업을 최대화하는 것이다. 다양한 하드웨어와 소프트웨어 자원이 어떻게 공유되느냐의
**자원의 이용(Resource Utilization)**에는 전혀 신경을 쓰지 않는다.

### 시스템 관점(System View)

컴퓨터 관점에서 운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램이다. 따라서 우리는 운영체제를
**자원 할당자(Resource Allocator)**로 볼 수 있다. 컴퓨터 시스템은 문제를 해결하기 위해
요구되는 여러 가지 자원들(하드웨어와 소프트웨어), 즉 CPU 시간, 메모리 공간, 저장장치 공간,
입출력 장치등을 가진다. 운영체제는 이들 자원의 관리자로서 동작한다. 자원에 대해 서로 상충할 수도 있는
많은 요청이 있으므로, 운영체제는 컴퓨터 시스템을 효율적이고 공정하게 운영할 수 있도록 어느 요청에
자원을 할당할지 결정해야 한다.

운영체제는 여러가지 입출력 장치와 사용자 프로그램을 제어해야한다. 따라서 운영체제는
**제어 프로그램(Control Program)**이다. 제어 프로그램은 컴퓨터의 부적절한 사용을 방지하기 위해
사용자 프로그램의 수행을 제어한다. 운영체제는 특히 입출력 장치의 제어와 작동에 깊게 관여한다.

### 운영체제의 정의

일반적으로 운영체제에 대한 적합한 정의는 없다. 운영체제는 유용한 컴퓨팅 시스템을 만드는 문제를
해결할 수 있는 합리적인 방법을 제공하기 때문에 존재한다. **컴퓨터 시스템의 기본 목표는 프로그램을
실행하고 사용자 문제를 더욱 쉽게 해결할 수 있게 하는 것이다.** 컴퓨터 하드웨어는 이 목표를
가지고 구성된다. 오로지 하드웨어만으로는 사용하기가 쉽지 않으므로 응용 프로그램이 개발된다.
이러한 프로그램에는 입출력 장치 제어와 같은 특정 공통 작업이 필요하다. 자원을 제어하고 할당하는
일반적인 기능은 운영체제라는 하나의 소프트웨어로 통합된다.

운영체제는 컴퓨터에서 항상 실행되는 프로그램(일반적으로 `커널`이라고 함)이다. 커널과 함께
두 가지 다른 유형의 프로그램이 있다. 운영체제와 관련되어 있지만 반드시 커널의 일부일 필요는 없는
**시스템 프로그램**과 시스템 작동과 관련되지 않은 모든 프로그램을 포함하는 **응용 프로그램**이다.

## 컴퓨터 시스템의 구성(Computer System Organization)

현대의 범용 컴퓨터 시스템은 하나 이상의 CPU와 구성요소와 공유 메모리 사이의 엑세스를 제공하는 공통
**버스**를 통해 연결된 여러 장치 컨트롤러로 구성된다.

일반적으로 운영체제는 각 장치 컨트롤러마다 **장치 드라이버**가 있다. 이 장치 드라이버는 장치
컨트롤러의 작동을 잘 알고 있고 나머지 운영체제 장치에 대한 일관된 인터페이스를 제공한다.
CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다. 공유 메모리를 질서 있게
엑세스하기 위해 메모리 컨트롤러는 메모리에 대한 엑세스를 동기화한다.

<Image
  src="https://user-images.githubusercontent.com/63354527/211206564-07a8b409-d8d7-4b0b-923a-33179f65c452.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211206564-07a8b409-d8d7-4b0b-923a-33179f65c452.png"
  description="통상적인 PC 컴퓨터 시스템"
/>

### 인터럽트(Interrupts)

하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다.
(컴퓨터 시스템에는 많은 버스가 있을 수 있지만 시스템 버스는 주요 구성요소 사이의 주요 통신 경로디.)
인터럽트는 다른 많은 목적으로도 사용되며 운영체제와 하드웨어의 상호 작용 방식의 핵심 부분이다.

CPU가 인터럽트 되면, CPU는 하던 일을 중단하고 즉시 고정된 위치로 실행을 옮긴다. 이러한 고정된 위치는
일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있다. 그리고 인터럽트 서비스 루틴이
실행된다. **인터럽트 서비스 루틴의 실행이 완료되면, CPU는 인터럽트 되었던 연산을 재개한다.**

각 컴퓨터 설계는 자신의 인터럽트 메커니즘을 가지고 있으며, 몇 가지 기능은 공통적이다.
인터럽트는 적절한 서비스 루틴으로 제어를 전달한다. 이러한 전달을 관리하는 직선적인 방법은 인터럽트 정보를
조사하는 일반적인 루틴을 호출하는 방법이다. 이 루틴은 이어 인터럽트 고유의 핸들러(handler)를 호출한다.
그러나, 인터럽트는 매우 빈번하게 발생하기 때문에 빠르게 처리되어야 한다. 필요한 속도를 제공하기 위해
인터럽트 서비스 루틴에 대한 포인터들의 테이블을 대신 이용할 수 있다. 이 경우 중간 루틴을 돌 필요 없이,
테이블을 통하여 간접적으로 인터럽트 루틴이 호출될 수 있다. 일반적으로 포인터들의 테이블은 하위 메모리에
저장된다. 이들 위치에서는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어있다.
인터럽트가 요청되면, 인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해
이 주소의 배열, 즉 `인터럽트 벡터`가 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인된다.

<Image
  src="https://user-images.githubusercontent.com/63354527/211700046-2984ef43-500c-4533-b99a-56bd4e1efd65.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211700046-2984ef43-500c-4533-b99a-56bd4e1efd65.png"
  description="출력을 수행하고 있는 단일 프로세스에 대한 인터럽트 시간 일정"
/>

<br />

인터럽트 구조는 또한 인터럽트된 모든 정보를 저장해야 인터럽트를 처리한 후 이 정보를 복원할 수 있다.
만약 만약 인터럽트 루틴이 처리기의 상태를 변경할 필요(예를 들어 레지스터의 값을 변경하여)가 있다면,
인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장하여야 하며, 복귀하기 전에 상태를 복원해야 한다.
인터럽트를 서비스한 후, 저장되어 있던 복귀 주소를 프로그램 카운터에 적재하고, 인터럽트에 의해
중단되었던 연산이 인터럽트가 발생되지 않았던 것처럼 다시 시작된다.

#### 구현(Implementation)

CPU 하드웨어는 `인터럽트 요청 라인(interrupt request line)`이라는 선이 있는데, 하나의 명령어의
실행을 완료할 때마다 CPU가 이 선을 감지한다. CPU가 컨트롤러가 인터럽트 요청 라인에 신호를 보낸 것을
감지하면, 인터럽트 번호를 읽고 이 번호를 인터럽트 벡터의 인덱스로 사용하여
`인터럽트 핸들러 루틴(interrupt-handler routine)`으로 점프한다. 그런 다음 해당 인덱스와 관련된
주소에서 실행을 시작한다. 인터럽트 처리기는 작업 중에 변경될 상태를 저장하고, 언터럽트 원인을 확인하고,
필요한 처리를 수행하고, 상태 복원을 수행하고, return_from_interrupt 명령어를 실행하여 CPU를
인터럽트 전 실행 상태로 되돌린다. 장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트를
발생시키고 CPU는 인터럽트를 포착(catch)하여 인터럽트 핸들러로 디스패치(dipatch)하고 핸들러는
장치를 서비스하여 인터럽트를 지운다(clear).

<Image
  width="400px"
  src="https://user-images.githubusercontent.com/63354527/211702248-741e139c-6988-455c-bcb8-6d3a033d2e20.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211702248-741e139c-6988-455c-bcb8-6d3a033d2e20.png"
  description="인터럽트-구동 방식의 입출력 사이클"
/>

<br />

최신 운영체제에서는 더욱 정교한 인터럽트 처리 기능이 필요하다.

1. 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 한다.
2. 장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법이 필요하다.
3. 운영체제가 우선순위가 높은 인터럽트와 우선순위가 낮은 인터럽트를 구분하고 적절한 긴급도로 대응할 수
   있도록 다단계 인터럽트가 필요하다.

최신 컴퓨터 하드웨어에서 이 세가지 기능은 CPU 및 `인터럽트 컨트롤러 하드웨어`에 의해 제공된다.

대부분의 CPU에는 2개의 인터럽트 요청 라인이 있다. 하나는 복구할 수 없는 메모리 오류와 같은 이벤트를
위해 예약된 `마스크 불가능 인터럽트`(nonmaskable interrupt)이다. 두 번째 인터럽트 라인은
`마스킹 가능`(maskable)이다. 인터럽트 되어서는 안되는 ㅈ둥요한 명령 시퀀스를 싱행하기 전에 CPU에 의해
꺼질 수 있다.

벡터 방식 인터럽트 기법의 목적은 서비스가 필요한 장치를 결정하기 위해 하나의 인터럽트 핸들러가 가능한
모든 인터럽트 소스를 검색할 필요를 줄이기 위한 것이다. 그러나 실제로 컴퓨터에는 인터럽트 벡터의 주소
개수보다 많은 장치가 있다. 이 문제를 해결하는 일반적인 방법은 `인터럽트 체인`을 사용하는 것이다.
인터럽트 벡터의 각 원소는 인터럽트 핸들러 리스트의 헤드를 가리킨다. 인터럽트가 발생하면 요청을
처리할 수 있는 핸들러가 발견될 때까지 상응하는 리스트의 핸들러가 하나씩 호출된다. 이러한 구조는
큰 크기의 인터럽트 테이블의 오버헤드와 하나의 인터럽트 핸들러로 디스패치 하는 비효율성의 절충안이다.

<Image
  width="400px"
  src="https://user-images.githubusercontent.com/63354527/211706225-f5d6a9a8-662b-4545-8047-57cca7a1454c.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211706225-f5d6a9a8-662b-4545-8047-57cca7a1454c.png"
  description="Intel 처리기 이벤트-벡터 테이블"
/>

위 사진은 인텔 프로세스의 인터럽트 벡터 설계를 보여준다. 마스크 불가능한 0에서 31까지의 이벤트는 다양한
오류 조건을 알리는데 사용된다. 마스크 가능한 32에서 255까지의 이벤트는 장치가 생성한 인터럽트 같은
그 외 인터럽트를 처리하기 위해서 사용된다.

인터럽트 기법은 또한 인터럽트 우선순위 레벨(interrupt priority level)을 구현한다. 이러한 레벨을
통해 CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위가 낮은 인터럽트 처리를 연기할 수 있고, 우선순위가
높은 인터럽트가 우선순위가 낮은 인터럽트의 실행을 선점할 수 있다.

요약하면, 인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 위해 사용된다. 장치 컨트롤러 및 하드웨어
오류로 인해 인터럽트가 발생한다. 가장 긴급한 작업을 먼저 수행하기 위해 최신 컴퓨터는 인터럽트 우선순위
시스템을 사용한다. 인터럽트는 시간에 민감한 처리에 빈번하게 사용되므로 시스템 성능을 좋게 하려면
효율적인 인터럽트 처리가 필요하다.

### 저장장치 구조(Storage Structure)

CPU는 메모리에서만 명령을 적재할 수 있으므로 실행하려면 프로그램을 먼저 메모리에 적재해야 한다.
범용 컴퓨터는 프로그램 대부분을 메인 메모리(`random-access memory`, 또는 `RAM`이라 불린다)라 불리는
재기록 가능한 메모리에서 가져온다. 메인 메모리는 `dynamic random-access memory`(`DRAM`)라 불리는
반도체 기술로 구현된다.

컴퓨터는 다른 형태의 메모리도 사용한다. 예를 들어, 컴퓨터 전원을 켤 때 가장 먼저 실행되는 프로그램은
`부트스트랩 프로그램`이며 운영체제를 적재한다. RAM은 휘발성(전원이 꺼지거나 손실될 때 내용이 손실됨)이므로
부트스트랩 프로그램을 유지하는 용도로 사용할 수 없다. 대신 이 목적과 다른 목적으로, 컴퓨터는 전기적으로
소거 가능한 프로그램 가능 읽기 전용 메모리(`EEPROM`) 및 기타 형태의 `펌웨어`(쓰기 작업이 자주 발생하지 않고
비휘발성인 저장장치)를 사용한다. EEPROM은 변경할 수는 있지만 자주 변경할 수는 없다. 또한 속도가 느리므로
주로 사용되지 않는 정적 프로그램과 데이터가 포함되어 있다. 예를 들어, iPhone은 EEPROM을 사용하여 장치의
일련 번호 및 하드웨어 정보를 저장한다.

모든 형태의 메모리는 바이트 배열을 제공한다. 각 바이트는 자신의 주소를 가지고 있다. 상호 작용은 특정 메모리
주소들에 대한 일련의 적재(load), 또는 저장(store)명령을 통해 이루어진다. 적재 명령은 메인 메모리로부터
CPU 내부의 레지스터로 한 바이트 또는 한 워드를 옮기는 것이다. 반대로 저장 명령은 한 레지스터의 내용을
메인 메모리로 옮긴다. 명시적인 적재, 저장 명령 외에, CPU는 프로그램 카운터에 저장된 위치부터 실행하기
위해 메인 메모리에서 명령을 자동으로 적재한다.

폰 노이만 구조 시스템에서 실행되는 전형적인 명령-실행 사이클은 먼저 메모리로부터 명령을 인출해, 그 명령을
명령 레지스터(instruction register)에 저장한다. 이어서 명령을 해독하고, 이는 메모리로부터 피연산자를
인출하여 내부 레지스터에 저장하도록 유발할 수 있다. 피연산자에 대해 명령을 실행한 후에 결과가 메모리에 다시
저장될 수 있다.

:::info
**저장 장치와 표기**
한 바이트는 8비트이고 대부분 컴퓨터에서는 가장 작은 편리한 저장 단위이다. 예를 들면 대부분의 컴퓨터들은
하나의 비트를 이동하는 명령어는 제공하지 않지만 한 바이트를 이동하는 명령어는 제공한다. 약간 덜 알려진
용어가 `워드`이다. 워드는 그 컴퓨터 구조의 본연의 데이터 단위이다. 한 워드는 하나 이상의 바이트로
구성된다. 예를 들면 64비트 레지스터들과 64비트 메모리 주소지정을 가지는 컴퓨터는 전형적으로
64비트(8바이트) 워드를 가진다. 컴퓨터는 많은 연산을 한 번에 한 바이트 단위가 아니라 본연의 워드 단위로
실행한다.  
컴퓨터 저장장치는 대부분의 컴퓨터 처리량과 마찬가지로 바이트 단위 및 바이트의 집합 단위로 측정되며 조작된다.
1킬로바이트 또는 KB는 1024바이트이고, 1메가바이트 또는 MB는 1024^2바이트, 1기가바이트 또는 GB는
1024^3바이트, 1테라바이트 또는 TB는 1024^4바이트, 1페타바이트 또는 PB는 1024^5바이트이다.
:::

이상적으로는, 프로그램과 데이터가 메인 메모리에 영구히 존재하기를 원한다. 그러나 이는 대부분의 시스템에서
두 가지 이유로 불가능하다.

1. 메인 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작다.
2. 메인 메모리는 이미 언급한 것처럼 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 저장장치이다.

그러므로 대부분의 컴퓨터 시스템은 메인 메모리의 확장으로 보조저장장치를 제공한다. 보조저장장치의 주요 요건은
대량의 데이터를 영구히 보존할 수 있어야 한다는 점이다.

가장 일반적인 보조저장장치는 하드 디스크 드라이브(HDD)와 비휘발성 메모리(NVM) 장치로, 프로그램과 데이터
모두를 위한 저장소를 제공한다. 대부분의 프로그램(시스템 및 응용 프로그램)은 메모리에 적재될 때까지
보조저장장치에 저장된다. 그런 후 많은 프로그램이 보조저장장치를 처리 소스 및 대상으로 모두 사용한다.
보조저장장치도 메인 메모리보다 훨씬 느리다.

:::info
다른 저장 장치에 저장된 자료의 백업 사본을 저장하기 위해 특수 목적으로만 사용하기에 매우 느리고 충분히
큰 장치를 3차 저장장치라고 한다.
:::

다양한 저장장치 시스템은 저장 용량 및 엑세스 시간에 따라 계층 구조로 구성될 수 있다. 일반적으로
크기와 속도 사이에는 상충하는 측면이 있어서 메모리가 작고 빠를수록 CPU에 더 가깝다.

<Image
  width="500px"
  src="https://user-images.githubusercontent.com/63354527/211716276-ff2cc672-de6b-483b-b8f6-0cbcad37691e.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211716276-ff2cc672-de6b-483b-b8f6-0cbcad37691e.png"
  description="저장장치 계층 구조"
/>
<br />

위 그림에서 최상위 4단계 메모리는 반도체 기반 전자회로로 구성된 반도체 메모리를 사용하여 구성된다.
네 번째 수준의 NVM 장치에는 여러가지 변형이 있지만 일반적으로 하드 디스크보다 빠르다. NVM 장치의
가장 일반적인 형태는 스마트폰 및 태블릿과 같은 모바일 장치에서 널리 사용되는 플래시 메모리이다.
점차 랩톱, 데스크톱과 서버에서의 장기 저장에도 플래시 메모리가 사용되고 있다.

비휘발성 저장장치는 전원이 꺼졌을 때 내용을 유지한다. 이를 NVS라고 한다. 대부분의 NVS의 경우
보조저장장치를 가리킨다. 이 유형의 저장장치는 다음 두가지 유형으로 분류될 수 있다.

- 기계적: 이러한 저장장치 시스템의 몇 가지 예는 HDD, 광디스크, 홀로그램 저장장치 및 자기 테이프이다.
  특정 유형의 기계식 저장장치(예: 자기 테이프)를 강조해야 하는 경우 명시적으로 그 용어를 사용할 것이다.
- 전기적: 이러한 저장장치 시스템의 몇 가지 예를 플래시 메모리, FRAM, NRAM 및 SSD이다. 전기적
  저장장치를 NVM으로 부른다.

일반적으로 전기적 저장장치보다 용량이 크고 바이트당 비용이 저렴하다. 반대로, 전기적 저장장치는
일반적으로 기계적 저장장치보다 비싸고 용량이 적으며 빠르다.

완전한 저장장치 시스템의 설계는 모든 요소의 균형을 맞춰야 한다. 가능한 한 많은 저렴한 비휘발성 저장장치를
제공하는 동시에 필요한 만큼만 비싼 메모리를 사용해야 한다. 캐시는 두 구성요소 간에 엑세스 시간이나
전송 속도의 차이가 큰 경우 성능을 향상하기 위해 설치할 수 있다.

### 입출력 구조(I/O Structure)

운영체제 코드의 상당 부분은 시스템의 안정성과 성능에 대한 중요성과 장치에 다양한 특성으로 인해 I/O 관리에 할애된다.

인터럽트 구동 I/O의 형태는 소량의 데이터를 이동하는데 좋지만 NVS I/O와 같이 대량 데이터 이동에 사용될 때 높은
오버헤드를 유발할 수 있다. 이 문제를 해결하기 위해 직접 메모리 액세스(DMA)가 사용된다.
장치에 대한 버퍼 및 포인터, 입출력 카운트를 세팅한 후 장치 제어기는 CPU의 개입없이 메모리로부터
자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체를 전송한다. 속도가 느린 장치처럼 한 바이트마다
인터럽트가 발생하는 것이 아니라 블록 전송이 완료될 때마다 인터럽트가 발생한다. 장치 컨트롤러가 전송 작업을
수행하고 있는 동안 CPU는 다른 작업을 수행할 수 있다.

<Image
  src="https://user-images.githubusercontent.com/63354527/211746320-224df88d-a1c3-4658-8f6e-3e12ccc5c159.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211746320-224df88d-a1c3-4658-8f6e-3e12ccc5c159.png"
  description="현대 컴퓨터의 작동방식"
/>

## Reference

- Operating System Concepts(공룡책)
