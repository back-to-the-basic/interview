import Image from '@site/src/components/Image';

# 서론

**운영체제(Operating System)**는 컴퓨터 하드웨어를 관리하는 소프트웨어이다. 운영체제는
응용 프로그램을 위한 기반을 제공하며 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 한다.

운영체제의 목적은 사용자가 프로그램을 편리하고 효율적으로 수행할 수 있는 환경을
제공하는데 있다.

<Image
  src="https://user-images.githubusercontent.com/63354527/211204342-9d3ec1e1-1de6-4f34-a189-ef8e576e8bf6.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211204342-9d3ec1e1-1de6-4f34-a189-ef8e576e8bf6.png"
  description="운영체제의 계층적 위치"
  width="400px"
/>

<br />

## 운영체제가 할 일(What Operating Systems Do)

컴퓨터 시스템은 대게 네 가지 구성요소인 하드웨어, 운영체제, 응용 프로그램 및 사용자로 구분할 수 있다.
하드웨어는 `중앙 처리 장치(CPU)`, `메모리 및 입출력(I/O) 장치`로 구성되어,기본 계산용 자원을 제공한다.
운영체제는 다양한 사용자를 위해 다양한 응용 프로그램 간의 하드웨어 사용을 제어하고 조정한다.

컴퓨터 시스템은 하드웨어, 소프트웨어 및 데이터로 구성되어 있다고 볼 수 있다. 운영체제는 컴퓨터 시스템이
동작할 때 이들 자원을 적절하게 사용할 수 있는 방법을 제공한다.

운영체제의 역할을 좀 더 완전히 이해하기 위해 사용자 관점과 시스템 관점에서 살펴볼 수 있다.

### 사용자 관점(User View)

컴퓨터를 사용하는데 있어서 사용자 관점에서의 목표는 **손쉬운 사용**이다. 많은 컴퓨터 사용자는 랩톱 혹은 모니터,
키보드, 마우스로 구성된 PC 앞에서 작업한다. 이러한 시스템은 한 사용자가 자원을 독점하도록 설계되었으며
목표는 사용자가 수행하는 작업을 최대화하는 것이다. 다양한 하드웨어와 소프트웨어 자원이 어떻게 공유되느냐의
**자원의 이용(Resource Utilization)**에는 전혀 신경을 쓰지 않는다.

### 시스템 관점(System View)

컴퓨터 관점에서 운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램이다. 따라서 우리는 운영체제를
**자원 할당자(Resource Allocator)**로 볼 수 있다. 컴퓨터 시스템은 문제를 해결하기 위해
요구되는 여러 가지 자원들(하드웨어와 소프트웨어), 즉 CPU 시간, 메모리 공간, 저장장치 공간,
입출력 장치등을 가진다. 운영체제는 이들 자원의 관리자로서 동작한다. 자원에 대해 서로 상충할 수도 있는
많은 요청이 있으므로, 운영체제는 컴퓨터 시스템을 효율적이고 공정하게 운영할 수 있도록 어느 요청에
자원을 할당할지 결정해야 한다.

운영체제는 여러가지 입출력 장치와 사용자 프로그램을 제어해야한다. 따라서 운영체제는
**제어 프로그램(Control Program)**이다. 제어 프로그램은 컴퓨터의 부적절한 사용을 방지하기 위해
사용자 프로그램의 수행을 제어한다. 운영체제는 특히 입출력 장치의 제어와 작동에 깊게 관여한다.

### 운영체제의 정의

일반적으로 운영체제에 대한 적합한 정의는 없다. 운영체제는 유용한 컴퓨팅 시스템을 만드는 문제를
해결할 수 있는 합리적인 방법을 제공하기 때문에 존재한다. **컴퓨터 시스템의 기본 목표는 프로그램을
실행하고 사용자 문제를 더욱 쉽게 해결할 수 있게 하는 것이다.** 컴퓨터 하드웨어는 이 목표를
가지고 구성된다. 오로지 하드웨어만으로는 사용하기가 쉽지 않으므로 응용 프로그램이 개발된다.
이러한 프로그램에는 입출력 장치 제어와 같은 특정 공통 작업이 필요하다. 자원을 제어하고 할당하는
일반적인 기능은 운영체제라는 하나의 소프트웨어로 통합된다.

운영체제는 컴퓨터에서 항상 실행되는 프로그램(일반적으로 `커널`이라고 함)이다. 커널과 함께
두 가지 다른 유형의 프로그램이 있다. 운영체제와 관련되어 있지만 반드시 커널의 일부일 필요는 없는
**시스템 프로그램**과 시스템 작동과 관련되지 않은 모든 프로그램을 포함하는 **응용 프로그램**이다.

## 컴퓨터 시스템의 구성(Computer System Organization)

현대의 범용 컴퓨터 시스템은 하나 이상의 CPU와 구성요소와 공유 메모리 사이의 엑세스를 제공하는 공통
**버스**를 통해 연결된 여러 장치 컨트롤러로 구성된다.

일반적으로 운영체제는 각 장치 컨트롤러마다 **장치 드라이버**가 있다. 이 장치 드라이버는 장치
컨트롤러의 작동을 잘 알고 있고 나머지 운영체제 장치에 대한 일관된 인터페이스를 제공한다.
CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다. 공유 메모리를 질서 있게
엑세스하기 위해 메모리 컨트롤러는 메모리에 대한 엑세스를 동기화한다.

<Image
  src="https://user-images.githubusercontent.com/63354527/211206564-07a8b409-d8d7-4b0b-923a-33179f65c452.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211206564-07a8b409-d8d7-4b0b-923a-33179f65c452.png"
  description="통상적인 PC 컴퓨터 시스템"
/>

### 인터럽트(Interrupts)

하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다.
(컴퓨터 시스템에는 많은 버스가 있을 수 있지만 시스템 버스는 주요 구성요소 사이의 주요 통신 경로디.)
인터럽트는 다른 많은 목적으로도 사용되며 운영체제와 하드웨어의 상호 작용 방식의 핵심 부분이다.

CPU가 인터럽트 되면, CPU는 하던 일을 중단하고 즉시 고정된 위치로 실행을 옮긴다. 이러한 고정된 위치는
일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있다. 그리고 인터럽트 서비스 루틴이
실행된다. **인터럽트 서비스 루틴의 실행이 완료되면, CPU는 인터럽트 되었던 연산을 재개한다.**

각 컴퓨터 설계는 자신의 인터럽트 메커니즘을 가지고 있으며, 몇 가지 기능은 공통적이다.
인터럽트는 적절한 서비스 루틴으로 제어를 전달한다. 이러한 전달을 관리하는 직선적인 방법은 인터럽트 정보를
조사하는 일반적인 루틴을 호출하는 방법이다. 이 루틴은 이어 인터럽트 고유의 핸들러(handler)를 호출한다.
그러나, 인터럽트는 매우 빈번하게 발생하기 때문에 빠르게 처리되어야 한다. 필요한 속도를 제공하기 위해
인터럽트 서비스 루틴에 대한 포인터들의 테이블을 대신 이용할 수 있다. 이 경우 중간 루틴을 돌 필요 없이,
테이블을 통하여 간접적으로 인터럽트 루틴이 호출될 수 있다. 일반적으로 포인터들의 테이블은 하위 메모리에
저장된다. 이들 위치에서는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어있다.
인터럽트가 요청되면, 인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해
이 주소의 배열, 즉 `인터럽트 벡터`가 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인된다.

<Image
  src="https://user-images.githubusercontent.com/63354527/211700046-2984ef43-500c-4533-b99a-56bd4e1efd65.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211700046-2984ef43-500c-4533-b99a-56bd4e1efd65.png"
  description="출력을 수행하고 있는 단일 프로세스에 대한 인터럽트 시간 일정"
/>

<br />

인터럽트 구조는 또한 인터럽트된 모든 정보를 저장해야 인터럽트를 처리한 후 이 정보를 복원할 수 있다.
만약 만약 인터럽트 루틴이 처리기의 상태를 변경할 필요(예를 들어 레지스터의 값을 변경하여)가 있다면,
인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장하여야 하며, 복귀하기 전에 상태를 복원해야 한다.
인터럽트를 서비스한 후, 저장되어 있던 복귀 주소를 프로그램 카운터에 적재하고, 인터럽트에 의해
중단되었던 연산이 인터럽트가 발생되지 않았던 것처럼 다시 시작된다.

#### 구현(Implementation)

CPU 하드웨어는 `인터럽트 요청 라인(interrupt request line)`이라는 선이 있는데, 하나의 명령어의
실행을 완료할 때마다 CPU가 이 선을 감지한다. CPU가 컨트롤러가 인터럽트 요청 라인에 신호를 보낸 것을
감지하면, 인터럽트 번호를 읽고 이 번호를 인터럽트 벡터의 인덱스로 사용하여
`인터럽트 핸들러 루틴(interrupt-handler routine)`으로 점프한다. 그런 다음 해당 인덱스와 관련된
주소에서 실행을 시작한다. 인터럽트 처리기는 작업 중에 변경될 상태를 저장하고, 언터럽트 원인을 확인하고,
필요한 처리를 수행하고, 상태 복원을 수행하고, return_from_interrupt 명령어를 실행하여 CPU를
인터럽트 전 실행 상태로 되돌린다. 장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트를
발생시키고 CPU는 인터럽트를 포착(catch)하여 인터럽트 핸들러로 디스패치(dipatch)하고 핸들러는
장치를 서비스하여 인터럽트를 지운다(clear).

<Image
  width="400px"
  src="https://user-images.githubusercontent.com/63354527/211702248-741e139c-6988-455c-bcb8-6d3a033d2e20.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211702248-741e139c-6988-455c-bcb8-6d3a033d2e20.png"
  description="인터럽트-구동 방식의 입출력 사이클"
/>

<br />

최신 운영체제에서는 더욱 정교한 인터럽트 처리 기능이 필요하다.

1. 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 한다.
2. 장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법이 필요하다.
3. 운영체제가 우선순위가 높은 인터럽트와 우선순위가 낮은 인터럽트를 구분하고 적절한 긴급도로 대응할 수
   있도록 다단계 인터럽트가 필요하다.

최신 컴퓨터 하드웨어에서 이 세가지 기능은 CPU 및 `인터럽트 컨트롤러 하드웨어`에 의해 제공된다.

대부분의 CPU에는 2개의 인터럽트 요청 라인이 있다. 하나는 복구할 수 없는 메모리 오류와 같은 이벤트를
위해 예약된 `마스크 불가능 인터럽트`(nonmaskable interrupt)이다. 두 번째 인터럽트 라인은
`마스킹 가능`(maskable)이다. 인터럽트 되어서는 안되는 ㅈ둥요한 명령 시퀀스를 싱행하기 전에 CPU에 의해
꺼질 수 있다.

벡터 방식 인터럽트 기법의 목적은 서비스가 필요한 장치를 결정하기 위해 하나의 인터럽트 핸들러가 가능한
모든 인터럽트 소스를 검색할 필요를 줄이기 위한 것이다. 그러나 실제로 컴퓨터에는 인터럽트 벡터의 주소
개수보다 많은 장치가 있다. 이 문제를 해결하는 일반적인 방법은 `인터럽트 체인`을 사용하는 것이다.
인터럽트 벡터의 각 원소는 인터럽트 핸들러 리스트의 헤드를 가리킨다. 인터럽트가 발생하면 요청을
처리할 수 있는 핸들러가 발견될 때까지 상응하는 리스트의 핸들러가 하나씩 호출된다. 이러한 구조는
큰 크기의 인터럽트 테이블의 오버헤드와 하나의 인터럽트 핸들러로 디스패치 하는 비효율성의 절충안이다.

<Image
  width="400px"
  src="https://user-images.githubusercontent.com/63354527/211706225-f5d6a9a8-662b-4545-8047-57cca7a1454c.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211706225-f5d6a9a8-662b-4545-8047-57cca7a1454c.png"
  description="Intel 처리기 이벤트-벡터 테이블"
/>

위 사진은 인텔 프로세스의 인터럽트 벡터 설계를 보여준다. 마스크 불가능한 0에서 31까지의 이벤트는 다양한
오류 조건을 알리는데 사용된다. 마스크 가능한 32에서 255까지의 이벤트는 장치가 생성한 인터럽트 같은
그 외 인터럽트를 처리하기 위해서 사용된다.

인터럽트 기법은 또한 인터럽트 우선순위 레벨(interrupt priority level)을 구현한다. 이러한 레벨을
통해 CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위가 낮은 인터럽트 처리를 연기할 수 있고, 우선순위가
높은 인터럽트가 우선순위가 낮은 인터럽트의 실행을 선점할 수 있다.

요약하면, 인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 위해 사용된다. 장치 컨트롤러 및 하드웨어
오류로 인해 인터럽트가 발생한다. 가장 긴급한 작업을 먼저 수행하기 위해 최신 컴퓨터는 인터럽트 우선순위
시스템을 사용한다. 인터럽트는 시간에 민감한 처리에 빈번하게 사용되므로 시스템 성능을 좋게 하려면
효율적인 인터럽트 처리가 필요하다.

### 저장장치 구조(Storage Structure)

CPU는 메모리에서만 명령을 적재할 수 있으므로 실행하려면 프로그램을 먼저 메모리에 적재해야 한다.
범용 컴퓨터는 프로그램 대부분을 메인 메모리(`random-access memory`, 또는 `RAM`이라 불린다)라 불리는
재기록 가능한 메모리에서 가져온다. 메인 메모리는 `dynamic random-access memory`(`DRAM`)라 불리는
반도체 기술로 구현된다.

컴퓨터는 다른 형태의 메모리도 사용한다. 예를 들어, 컴퓨터 전원을 켤 때 가장 먼저 실행되는 프로그램은
`부트스트랩 프로그램`이며 운영체제를 적재한다. RAM은 휘발성(전원이 꺼지거나 손실될 때 내용이 손실됨)이므로
부트스트랩 프로그램을 유지하는 용도로 사용할 수 없다. 대신 이 목적과 다른 목적으로, 컴퓨터는 전기적으로
소거 가능한 프로그램 가능 읽기 전용 메모리(`EEPROM`) 및 기타 형태의 `펌웨어`(쓰기 작업이 자주 발생하지 않고
비휘발성인 저장장치)를 사용한다. EEPROM은 변경할 수는 있지만 자주 변경할 수는 없다. 또한 속도가 느리므로
주로 사용되지 않는 정적 프로그램과 데이터가 포함되어 있다. 예를 들어, iPhone은 EEPROM을 사용하여 장치의
일련 번호 및 하드웨어 정보를 저장한다.

모든 형태의 메모리는 바이트 배열을 제공한다. 각 바이트는 자신의 주소를 가지고 있다. 상호 작용은 특정 메모리
주소들에 대한 일련의 적재(load), 또는 저장(store)명령을 통해 이루어진다. 적재 명령은 메인 메모리로부터
CPU 내부의 레지스터로 한 바이트 또는 한 워드를 옮기는 것이다. 반대로 저장 명령은 한 레지스터의 내용을
메인 메모리로 옮긴다. 명시적인 적재, 저장 명령 외에, CPU는 프로그램 카운터에 저장된 위치부터 실행하기
위해 메인 메모리에서 명령을 자동으로 적재한다.

폰 노이만 구조 시스템에서 실행되는 전형적인 명령-실행 사이클은 먼저 메모리로부터 명령을 인출해, 그 명령을
명령 레지스터(instruction register)에 저장한다. 이어서 명령을 해독하고, 이는 메모리로부터 피연산자를
인출하여 내부 레지스터에 저장하도록 유발할 수 있다. 피연산자에 대해 명령을 실행한 후에 결과가 메모리에 다시
저장될 수 있다.

:::info
**저장 장치와 표기**
한 바이트는 8비트이고 대부분 컴퓨터에서는 가장 작은 편리한 저장 단위이다. 예를 들면 대부분의 컴퓨터들은
하나의 비트를 이동하는 명령어는 제공하지 않지만 한 바이트를 이동하는 명령어는 제공한다. 약간 덜 알려진
용어가 `워드`이다. 워드는 그 컴퓨터 구조의 본연의 데이터 단위이다. 한 워드는 하나 이상의 바이트로
구성된다. 예를 들면 64비트 레지스터들과 64비트 메모리 주소지정을 가지는 컴퓨터는 전형적으로
64비트(8바이트) 워드를 가진다. 컴퓨터는 많은 연산을 한 번에 한 바이트 단위가 아니라 본연의 워드 단위로
실행한다.  
컴퓨터 저장장치는 대부분의 컴퓨터 처리량과 마찬가지로 바이트 단위 및 바이트의 집합 단위로 측정되며 조작된다.
1킬로바이트 또는 KB는 1024바이트이고, 1메가바이트 또는 MB는 1024^2바이트, 1기가바이트 또는 GB는
1024^3바이트, 1테라바이트 또는 TB는 1024^4바이트, 1페타바이트 또는 PB는 1024^5바이트이다.
:::

이상적으로는, 프로그램과 데이터가 메인 메모리에 영구히 존재하기를 원한다. 그러나 이는 대부분의 시스템에서
두 가지 이유로 불가능하다.

1. 메인 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작다.
2. 메인 메모리는 이미 언급한 것처럼 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 저장장치이다.

그러므로 대부분의 컴퓨터 시스템은 메인 메모리의 확장으로 보조저장장치를 제공한다. 보조저장장치의 주요 요건은
대량의 데이터를 영구히 보존할 수 있어야 한다는 점이다.

가장 일반적인 보조저장장치는 하드 디스크 드라이브(HDD)와 비휘발성 메모리(NVM) 장치로, 프로그램과 데이터
모두를 위한 저장소를 제공한다. 대부분의 프로그램(시스템 및 응용 프로그램)은 메모리에 적재될 때까지
보조저장장치에 저장된다. 그런 후 많은 프로그램이 보조저장장치를 처리 소스 및 대상으로 모두 사용한다.
보조저장장치도 메인 메모리보다 훨씬 느리다.

:::info
다른 저장 장치에 저장된 자료의 백업 사본을 저장하기 위해 특수 목적으로만 사용하기에 매우 느리고 충분히
큰 장치를 3차 저장장치라고 한다.
:::

다양한 저장장치 시스템은 저장 용량 및 엑세스 시간에 따라 계층 구조로 구성될 수 있다. 일반적으로
크기와 속도 사이에는 상충하는 측면이 있어서 메모리가 작고 빠를수록 CPU에 더 가깝다.

<Image
  width="500px"
  src="https://user-images.githubusercontent.com/63354527/211716276-ff2cc672-de6b-483b-b8f6-0cbcad37691e.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211716276-ff2cc672-de6b-483b-b8f6-0cbcad37691e.png"
  description="저장장치 계층 구조"
/>
<br />

위 그림에서 최상위 4단계 메모리는 반도체 기반 전자회로로 구성된 반도체 메모리를 사용하여 구성된다.
네 번째 수준의 NVM 장치에는 여러가지 변형이 있지만 일반적으로 하드 디스크보다 빠르다. NVM 장치의
가장 일반적인 형태는 스마트폰 및 태블릿과 같은 모바일 장치에서 널리 사용되는 플래시 메모리이다.
점차 랩톱, 데스크톱과 서버에서의 장기 저장에도 플래시 메모리가 사용되고 있다.

비휘발성 저장장치는 전원이 꺼졌을 때 내용을 유지한다. 이를 NVS라고 한다. 대부분의 NVS의 경우
보조저장장치를 가리킨다. 이 유형의 저장장치는 다음 두가지 유형으로 분류될 수 있다.

- 기계적: 이러한 저장장치 시스템의 몇 가지 예는 HDD, 광디스크, 홀로그램 저장장치 및 자기 테이프이다.
  특정 유형의 기계식 저장장치(예: 자기 테이프)를 강조해야 하는 경우 명시적으로 그 용어를 사용할 것이다.
- 전기적: 이러한 저장장치 시스템의 몇 가지 예를 플래시 메모리, FRAM, NRAM 및 SSD이다. 전기적
  저장장치를 NVM으로 부른다.

일반적으로 전기적 저장장치보다 용량이 크고 바이트당 비용이 저렴하다. 반대로, 전기적 저장장치는
일반적으로 기계적 저장장치보다 비싸고 용량이 적으며 빠르다.

완전한 저장장치 시스템의 설계는 모든 요소의 균형을 맞춰야 한다. 가능한 한 많은 저렴한 비휘발성 저장장치를
제공하는 동시에 필요한 만큼만 비싼 메모리를 사용해야 한다. 캐시는 두 구성요소 간에 엑세스 시간이나
전송 속도의 차이가 큰 경우 성능을 향상하기 위해 설치할 수 있다.

### 입출력 구조(I/O Structure)

운영체제 코드의 상당 부분은 시스템의 안정성과 성능에 대한 중요성과 장치에 다양한 특성으로 인해 I/O 관리에 할애된다.

인터럽트 구동 I/O의 형태는 소량의 데이터를 이동하는데 좋지만 NVS I/O와 같이 대량 데이터 이동에 사용될 때 높은
오버헤드를 유발할 수 있다. 이 문제를 해결하기 위해 직접 메모리 액세스(DMA)가 사용된다.
장치에 대한 버퍼 및 포인터, 입출력 카운트를 세팅한 후 장치 제어기는 CPU의 개입없이 메모리로부터
자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체를 전송한다. 속도가 느린 장치처럼 한 바이트마다
인터럽트가 발생하는 것이 아니라 블록 전송이 완료될 때마다 인터럽트가 발생한다. 장치 컨트롤러가 전송 작업을
수행하고 있는 동안 CPU는 다른 작업을 수행할 수 있다.

<Image
  src="https://user-images.githubusercontent.com/63354527/211746320-224df88d-a1c3-4658-8f6e-3e12ccc5c159.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211746320-224df88d-a1c3-4658-8f6e-3e12ccc5c159.png"
  description="현대 컴퓨터의 작동방식"
/>

## 컴퓨터 시스템 구조(Computer System Architecture)

컴퓨터 시스템은 사용된 범용 처리기의 수에 따라 분류 가능한 다양한 방식으로 구성될 수 있다.

### 단일 처리기 시스템(Single Processor Systems)

몇 년 전, 대부분의 컴퓨터 시스템은 단일 처리 코어를 가진 하나의 CPU를 포함하는 단일 프로세서를
사용했다. 코어는 명령을 실행하고 로컬로 데이터를 저장하기 위한 레지스터를 포함하는 구성요소이다.
코어를 가진 하나의 메인 CPU는 프로세스의 명령어를 포함하여 범용 명령어 세트를 실행할 수 있다.
이 시스템에는 다른 특수 목적 프로세서도 있다. 디스크, 키보드 및 그래픽 컨트롤러와 같은 장치별
프로세서 형태로 제공될 수도 있다. 이 모든 전용 처리기들은 제한된 명령어 집합을 실행하고 사용자
프로세스를 싱행하지는 않는다. 때로 이 처리기들은 운영체제에 의해 관리되기도 하는데, 운영체제는
처리기들이 수행할 다음 태스크에 대한 정보를 보내고 처리기들의 상태를 감시한다. 예를 들면 디스크
컨트롤러 마이크로프로세서는 주 CPU로부터 연속된 요청을 받아들여 자기 고유의 디스크 큐와 스케줄링
알고리즘을 구현한다. 이 배합은 CPU가 직접 디스크 스케줄링을 해야 하는 오버헤드를 감소시킨다.

### 다중 처리기 시스템(Multiprocessor Systems)

모바일 장치에서 서버에 이르기까지 최신 컴퓨터에서는 다중 처리기 시스템이 컴퓨팅 환경을 지배하고 있다.
일반적으로 이러한 시스템에는 각각 단일코어 CPU가 있는 두개 이상의 프로세서가 있다. 프로세서는 컴퓨터
버스 및 때때로 클록, 메모리 및 주변 장치를 공유한다. 다중 처리기 시스템의 주요 장점은 처리량 증가이다.
즉 프로세서 수를 늘리면 더 적은 시간에 더 많은 작업을 수행할 수 있다. 그러나 N 프로세서의 속도 향상
비율은 N이 아니다. 여러 프로세서가 하나의 작업에 협력할 때 모든 프로세서가 올바르게 작동하게
유지하는 데 일정한 양의 오버헤드가 발생한다. 이 오버헤드와 공유 자원에 대한 경합은 추가 프로세서의
예상 이득을 낮춘다.

가장 일반적인 다중 처리기 시스템은 각 피어 CPU 프로세서가 운영체제 기능 및 사용자 프로세스를 포함한
모든 작업을 수행하는 `SMP`(symmetric multiprocessing)를 사용한다.

<Image
  src="https://user-images.githubusercontent.com/63354527/211752145-c751d4ff-86cd-47fd-8b25-dad42de8c2be.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/211752145-c751d4ff-86cd-47fd-8b25-dad42de8c2be.png"
  description="대칭형 다중 처리 구조(SMP)"
/>

위 그림은 각각 자체 CPU를 가지는 두 개의 프로세서가 있는 일반적인 SMP 구조를 보여준다. 각 CPU
처리기에는 개별 또는 로컬 캐시뿐만 아니라 자체 레지스터 세트가 있다. 그러나 모든 프로세서는
시스템 버스를 통해 물리 메모리를 공유한다. 이 모델의 장점은 많은 프로세스를 동시에 실행할 수 있다는
것이다. N개의 CPU가 독립적이기 때문에 하나는 유휴 상태이고 다른 하나는 과부하가 걸려 비효율적일 수
있다. 프로세서가 특정 자료구조를 공유하는 경우 이러한 비효율성을 피할 수 있다. 이 형식의 다중
처리기 시스템을 사용하면 프로세스 및 메모리와 같은 자원을 다양한 프로세서 간에 동적으로 공유할 수 있으며
프로세서 간의 작업 부하 분산을 낮출 수 있다.

다중 처리기의 정의는 시간이 지남에 따라 발전해왔으며 이제는 여러 개의 컴퓨팅 코어가 단일 칩에 상주하는
다중 코어 시스템을 포함한다. 칩 내 통신이 칩 간 통신보다 빠르므로 다중 코어 시스템은 단일 코어를 가지는
여러 칩보다 효율적일 수 있다. 또한 여러개의 코어를 가지는 하나의 칩은 여러 개의 단일 코어 칩보다 훨씬
적은 전력을 사용하는데, 이는 노트북뿐만 아니라 모바일 장치의 중요한 문제이다.

:::info
**컴퓨터 시스템 구성요소의 정의**

- CPU: 명령을 실행하는 하드웨어
- 프로세서(processor): 하나 이상의 CPU를 포함하는 물리적 칩
- 코어(core): CPU의 기본 계산 단위
- 다중 코어(multicore): 동일한 CPU에 여러 컴퓨팅 코어를 포함함
- 다중 처리기(multiprocessor): 여러 프로세서를 포함함

:::

다중 처리기 시스템에 CPU를 추가하면 컴퓨팅 성능이 향상된다. 그러나 앞에서 제안한 것처럼 이러한 개념은
그다지 확장성이 좋지 않고, CPU를 너무 많이 추가하면 시스템 버스에 대한 경합이 병목 현상이 되어 성능이
저하되기 시작한다. 다른 방법은 각 CPU(또는 CPU 그룹)에 작고 빠른 로컬 버스를 통해 액세스 되는 자체
로컬 메모리를 제공하는 것이다. 모든 CPU가 공유 시스템 연결로 연결되어 모든 CPU가 하나의 물리 주소
공간을 공유한다. **NUMA(non-uniform memory access)**라고 하는 이 방법은 CPU가 로컬 메모리에
액세스 할 때 빠를 뿐만 아니라 시스템 상호 연결에 대한 경합도 없다는 것이다.

<Image
  src="https://user-images.githubusercontent.com/63354527/212002914-6a79a3ea-3d58-40ac-8af5-ee864e1439fd.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/212002914-6a79a3ea-3d58-40ac-8af5-ee864e1439fd.png"
  description="NUMA 다중 처리 구조"
/>

CPU가 로컬 메모리에 액세스 할 때 빠를 뿐만 아니라 시스템 상호 연결에 대한 경합도 없다. 따라서 NUMA
시스템은 더 많은 프로세서가 추가될수록 더 효과적으로 확장할 수 있다.

### 클러스터형 시스템(Clustered Systems)

여러 CPU를 가진 시스템의 또 다른 유형은 클러스터형 시스템이다.
일반적으로 받아들여지는 정의에 의하면 클러스터 컴퓨터는 저장장치를 공유하고 근거리 통신망(local area
network, LAN)이나 InfiniBand와 같은 고속의 상호 연결망(interconnect)으로 연결된다.

클러스터링은 통상 높은 가용성(availability)를 제공하기 위해 사용된다. 즉 클러스터 내 하나 이상의 컴퓨터
시스템이 고장나더라도 서비스는 계속 제공된다. 일반적으로 높은 가용성은 시스템에 중복 기능을 추가함으로써
얻어진다. 클러스터 소프트웨어 중 한 층이 클러스터 노드에서 실행된다. 각 노드는 하나 이상의 다른 노드
(네트워크로 연결 되어 있는)들을 감시한다. 만일 감시받던 노드가 고장나면 감시하던 노드가 고장난 노드의
저장장치에 대한 소유권을 넘겨받고, 그 노드에서 실행 중이던 응용 프로그램을 다시 시작한다. 사용자와
응용 프로그램 클라이언트는 잠깐의 서비스 중단만을 경험하게 된다. 높은 가용성은 안정성을 향상해 많은
응용 프로그램에서 중요하다. 남아 있는 하드웨어 수준에 비례하여 서비스를 계속 제공하는 기능을
**우아한 성능 저하(graceful degradation)**라고 한다. 일부 시스템은 정상적인 성능 저하를 넘어
단일 구성요소에 오류가 발생하여도 계속 동작할 수 있으므로 결함허용 시스템이라고 한다. 결함허용에는 장애를
감지, 진단 및 가능한 경우 수정할 수 있는 기법이 필요하다.

클러스터링은 비 댗칭적으로 또는 대칭적으로 구성될 수 있다. **비대칭형 클러스터링**에서는 다른 컴퓨터들이
응용 프로그램을 실행하는 동안 한 컴퓨터는 **긴급 대기(hot-stanby) 모드** 상태를 유지한다. 이 긴급
대기 모드의 호스트는 활성 서버들을 감시하는 작업만을 수행한다. 서버가 고장 난다면 긴급 대기 모드의
호스트가 활성 서버가 된다. 대칭형 클러스터링에서는 둘 이상의 호스트들이 응용 프로그램을 실행하고 서로를
감시한다. 가용한 하드웨어를 모두 사용하기 때문에 대칭형 구성이 더 효율적이다. 대칭형 구성이 효율적으로
동작하기 위해서는 하나 이상의 응용 프로그램들이 실행 가능해야 한다.

한 클러스터가 네트워크로 연결된 다수의 컴퓨터 시스템으로 구성되므로 클러스터는 고성능 계산 환경을
제공하도록 사용될 수 있다. 이러한 시스템은 클러스터 내의 모든 컴퓨터에서 응용을 병렬 수행할 수 있으므로
단일 처리기나 SMP 시스템보다 훨씬 큰 계산 능력을 제공할 수 있다. 그렇지만 애플리케이션이 클러스터를
이용할 수 있도록 작성되어야 한다. 이는 **병렬화**라는 기법으로 프로그램을 컴퓨터의 개별 코어에서 혹은
클러스터의 각 컴퓨터에서 수행되는 분리된 요소로 나누는 작업을 포함한다. 전형적으로 이들 애플리케이션은
클러스터의 각 계산 노드가 문제 일부를 해결한 후 모든 노드의 결과를 결합하여 최종 해답을 얻게 된다.

:::info
**HADOOP**

Hadoop은 단순하고 저렴한 하드웨어 구성요소를 포함하는 클러스터형 시스템에서 대용량 데이터 세트
(빅데이터)의 분산 처리에 사용되는 공개 소프트웨어 프레임워크이다. Hadoop은 단일 시스템에서 수천개의
컴퓨팅 노드를 포함하는 클러스터로 확장되도록 설계되었다. 작업은 클러스터의 노드에 할당되며 Hadoop
은 노드 간 통신을 정렬하여 처리할 병렬 계산을 관리하고 결과를 통합한다. Hadoop은 또한 노드의 장애를
감지하고 관리하여 효율적이고 매우 안정적인 분산 컴퓨팅 서비스를 제공한다.
Hadoop은 다음 세가지로 구성된다.

1. 분산 컴퓨팅 노드에서 데이터와 파일을 관리하는 분산 파일 시스템
2. YARN(YET ANOTHER RESOURCE NEGOTIATOR) 프레임워크는 클러스터 내의 자원을 관리하고
   클러스터의 노드에 작업을 스케줄 한다.
3. MapReduce 시스템은 클러스터의 노드에서 데이터를 병렬 처리할 수 있게 한다.

:::

## 운영체제의 작동(Operating System Operations)

운영체제는 프로그램이 실행되는 환경을 제공한다. 내부적으로 운영체제는 여러 경로를 거쳐 구성되기 때문에
운영체제마다 큰 차이를 보인다. 그러나 많은 공통점이 존재하고. 이 절에서는 그 공통점들에 대해 논의한다.

컴퓨터의 전원을 켜거나 재부팅할 때와 같이 컴퓨터를 실행하려면 초기 프로그램을 실행해야 한다. 앞에서
언급했듯이 이 초기 프로그램 또는 부트스트랩 프로그램은 단순한 형태를 띠는 경향이 있다. 일반적으로
부트스트랩 프로그램은 컴퓨터 하드웨어 내에 펌웨어로 저장된다.

부트스트랩 프로그램은 CPU 레지스터에서 장치 컨트롤러, 메모리 내용에 이르기까지 시스템의 모든 측면을
초기화한다. 부트스트랩 프로그램은 운영체제를 적재하는 방법과 해당 시스템 실행을 시작하는 방법을
알아야 한다. 이 목표를 달성하려면 부트스트랩 프로그램이 운영체제 커널을 찾아 메모리에 적재해야 한다.

커널이 적재되어 실행되면 시스템과 사용자에게 서비스를 제공할 수 있다. 일부 서비스는 커널이 실행되는
전체 시간 동안 실행되는 시스템 데몬이 되기 위해 부팅할 때 메모리에 적재되는 시스셈 프로그램에 의해
커널 외부에서 제공된다. Linux에서 첫 번째 세스템 프로그램은 'systemd'이며 다른 많은 데몬을
시작한다. 이 단계가 완료되면 시스템은 완전히 부팅되고 시스템은 어떤 이벤트가 발생할 때까지 기다린다.

### 멀티 프로그래밍과 멀티 태스킹(Multiprogramming and multitasking)

운영체제의 가장 중요한 측면 중 하나는 하나의 프로그램은 일반적으로 항상 CPU나 I/O 장치를 항상
바쁘게 유지할 수 없으므로 여러 프로그램을 실행할 수 있다는 것이다. 또한 사용자는 일반적으로
한 번에 둘 이상의 프로그램을 실행하려고 한다. 멀티 프로그래밍은 CPU가 항상 한 개는 실행할 수 있도록
프로그램을 구성하여 CPU 이용률을 높이고 사용자 만족도를 높인다. 멀티 프로그램 시스템에서 실행 중인
프로그램을 **프로세스**라고 한다.

운영체제는 여러 프로세스를 동시에 메모리에 유지한다. 운영체제는 이러한 프로세스 중 하나를 선택하여
실행하기 시작한다. 결국 프로세스는 I/O 작업과 같은 일부 작업이 완료되기를 기다려야 할 수도 있다.
멀티 프로그래밍 되지 않은 시스템에서는 CPU가 유휴 상태가 발생할 수 있다. 다중 프로그램 시스템에서
운영체제는 단순히 다른 프로세스로 전환하여 실행한다. 해당 프로세스가 대기해야 하는 경우 CPU는 다른
프로세스로 전환한다. 결국 첫 번째 프로세스는 대기를 마치고 CPU를 다시 돌려받는다.

<Image
  src="https://user-images.githubusercontent.com/63354527/212238865-5cac0a60-f8c9-4f18-a6b6-dbc265317ea0.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/212238865-5cac0a60-f8c9-4f18-a6b6-dbc265317ea0.png"
  description="다중 프로그래밍 시스템을 위한 메모리 배치"
/>

멀티 태스킹(multitasking)은 멀티 프로그래밍의 논리적 확장이다. 멀티 태스킹 시스템에서 CPU는 여러
프로세스를 전환하며 프로세스를 실행하지만 전환이 자주 발생하여 사용자에게 빠른 응답 시간을 제공한다.
프로세스가 실행될 때 일반적으로 프로세스가 완료되거나 I/O를 수행하기 전에 짧은 시간 동안만 실행된다는
것을 고려하자. 입출력은 대화식일 수 있다. 즉, 출력이 사용자를 위해 디스플레이되고, 입력은 사용자 키보드,
마우스 또는 터치 스크린으로부터 들어온다. 이러한 대화식 입력이 진행되는 동안 CPU를 쉬게 하지 않고,
운영체제는 CPU를 다른 사용자의 프로그램으로 신속하게 전환한다.

멀티 태스킹 시스템에서 운영체제는 적절한 응답 시간을 보장해야 한다. 적절한 응답 시간을 보장하는 더
일반적인 방법은 가상 메모리(virtual memeory)인데, 이것은 일부만 메모리에 적재된 프로세스의 실행을
허용하는 기법이다. 이 기법의 주요한 이점은 프로그램이 물리 메모리의 크기보다 더 커도 된다는 것이다.
더욱이 가상 메모리는 메인 메모리를 크고 균등한 저장장치의 배열로 추상화하여, 사용자에게 보이는 논리
메모리를 물리 메모리로부터 분리시킨다. 이러한 기법은 프로그래머를 메모리 저장장치의 한계로부터 자유롭게
해준다.

### 이중모드와 다중모드 운용(Dual Mode and Multimode Operation)

운영체제와 사용자는 컴퓨터 시스템의 하드웨어 및 소프트웨어 자원을 공유하기 때문에 올바르게
설계된 운영체제는 잘못된 프로그램으로 인해 다른 프로그램 또는 운영체제가 잘못 실행될 수 없도록
보장해야 한다. 시스템을 올바르게 실행하려면 운영체제 코드 실행과 사용자 정의 코드 실행을 구분할 수 있어야
한다. 대부분의 컴퓨터 시스템이 취하는 접근 방식은 다양한 실행모드를 차별화 할 수 있는 하드웨어 자원을
제공하는 것이다.

적어도 두 개의 독립된 연산 모드, 즉 사용자 모드와 커널 모드[수퍼바이저 모드,
시스템 모드], 혹은 **특권 모드**(privileged mode)를 필요로한다. 모드 비트(mode bit)라고
하는 하나ㅡ이 비트가 현재의 모드를 나타내기 위해 컴퓨터의 하드웨어에 추가되었다. 이 비트는
커널 모드(0) 또는 사용자 모드(1)을 나타낸다. 모드 비트의 사용으로, 우리는 운영체제를 위하여 실행되는
작업과 사용자를 위해 실행되는 작업을 구분할 수 있다. 컴퓨터 시스템이 사용자의 애플리케이션을 위하여
실행될 때 시스템은 사용자 모드에 있게 된다. 그러나 사용자 애플리케이션이 운영체제로부터 서비스를
요청하면(시스템 콜을 통함) 이 요청을 수행하기 위해서는 사용자 모드에서 커널 모드로 전환해야 한다.

시스템 부트 시, 하드웨어어는 커널 모드에서 시작한다. 이어 운영체제가 적재되고, 사용자 모드에서
사용자 프로세스가 시작된다. 트랩이나 인터럽트가 발생할 때마다, 하드웨어는 사용자 모드에서
커널 모드로 전환된다. 그러므로 운영체제가 컴퓨터의 제어를 얻을 때마다 항상 커널 모드에 있게 된다.
시스템은 사용자 프로그램으로 제어를 넘기기 전에 항상 사용자 모드로 전환한다.

<Image
  src="https://user-images.githubusercontent.com/63354527/213631255-2f42fa14-1854-4ec4-869e-196d028c103a.png"
  referenceLink="https://user-images.githubusercontent.com/63354527/213631255-2f42fa14-1854-4ec4-869e-196d028c103a.png"
  description="사용자 모드에서 커널 모드로의 전환"
/>

<br />

동작의 이중 모드는 잘못된 사용자로부터 운영체제를, 그리고 잘못된 사용자 서로를 보호하는 방법을
우리에게 제공한다. 우리는 이러한 악영향을 끼칠 수 있는 일부 명령을
**특권 명령**(**privileged instruction**)으로 지정함으로써
이러한 보호를 달성한다. 하드웨어는 특권 명령이 커널 모드에서만 수행되도록 허용한다. 사용자 모드에서
특권 명령을 수행하려고 시도하면, 하드웨어는 이를 실행하지 않고, 불법적인 명령으로 간주해 운영체제로
트랩을 건다.

커널 모드로 전환하는 명령어가 특권 명령어의 예이다. 다른 예로는 I/O 제어, 타이머 관리 및 인터럽트 관리가
있다.

시스템 콜은 사용자 프로그램이 자신을 대신하여 운영체제가 수행하도록 지정되어 있는 작업을 운영체제에게
요청할 수 있는 방법을 제공한다. 시스템 콜은 컴퓨터 시스템의 처리기가 지원하는 기능에 따라 다양한 방법으로
호출된다. 어떠한 형태를 가지든 시스템 콜은 운영체제에 의해 수행될 동작을 사용자 프로세스가 요청할 수 있게
한다. 시스템 콜은 일반적으로 인터럽트 벡터의 특정 위치로 트랩을 거는 형태를 취한다. 이 트랩은 보통의
trap 명령어를 통해 수행되지만 몇몇 시스템은 syscall 이라는 특정 명령어를 가지기도 한다.

시스템 콜이 수행될 때 시스템 콜은 하드웨어에 의해 하나의 소프트웨어 인터럽트로 취급된다.
제어가 인터럽트 벡터를 통해 운영체제 내의 서비스 루틴으로 전달되고, 모드 비트가 커널 모드로 설정된다.
시스템 콜 서비스 루틴은 운영체제의 일부이다. 커널은 인터럽트를 발생시킨 명령을 검사하여 어떤 시스템 콜이
발생했는지를 결정한다. 이 떄 전달된 인수가 사용자 프로그램이 요청하는 서비스 유형을 표시한다.
요청이 필요로 하는 추가의 정보는 레지스터, 스택 또는 메모리로(이때는 메모리 위치에 대한 포인터가
레지스터에 전달된다) 전달될 수 있다. 커널은 인수가 정확하고 합법적인지를 검증하고 요청을 수행한 후
제어를 시스템 콜 다음 명령으로 복귀한다.

### 타이머(Timer)

우리는 운영체제가 CPU에 대한 제어를 유지할 수 있도록 보장해야 한다. 우리는 사용자 프로그램이 무한 루프에
빠지거나 시스템 서비스 호출에 실패하여, 제어가 운영체제로 복귀하지 않는 경우가 없도록 반드시 방지해야
한다. 이러한 목적을 달성하기 위해 **타이머**를 사용할 수 있다. 타이머는 지정된 시간 후 컴퓨터를
인터럽트 하도록 설정할 수 있다. 이 시간은 고정(예를 들면, 1/60초), 혹은 가변(1밀리초에서 1초까지)일
수 있다.

사용자에게 제어를 양도하기 전에, 운영체제는 타이머가 인터럽트를 할 수 있도록 설정되었는지를 확인한다.
만약 타이머가 인터럽트를 발생하면 제어는 자동으로 운영체제에 넘어가며, 운영체제는 인터럽트를 치명적인
오류로 취급하거나, 또는 프로그램에게 더 많은 시간을 줄 수 있다. 타이머의 값을 변경한느 명령은 명백히
특권 명령이다.

## 자원 관리(Resource Management)

운영체제는 자원 관리자이다. 시스템의 CPU, 메모리 공간, 파일 저장공간 및 I/O 장치는 운영체제가
관리해야 하는 자원에 속한다.

### 프로세스 관리(Process Management)

프로세스는 자기 일을 수행하기 위해 CPU 시간, 메모리, 파일, 그리고 입출력 장치를 포함한 여러 가지
자원을 필요로 한다. 이러한 자원은 보통 실행되는 동안 할당된다. 예를 들어 웹 페이지의 내용을 화면에
표시하는 기능을 가진 웹 브라우저를 실행하는 프로세스를 고려하자. 프로세스는 URL을 입력으로
제공받으며 적절한 명령과 시스템 콜을 실행하여 원하는 정보를 얻고 화면에 표시한다. 프로세스가
종료되면 운영체제는 재사용 가능한 자원을 회수한다.

프로그램 그 자체는 프로세스가 아니다. 즉, 하나의 프로그램은 디스크에 저장된 파일의 내용과 같이
수동적(passive) 개체이지만 프로세스는 다음 수행할 명령을 지정하는 프로그램 카운터를 가진
능동적인 개체이다. 한 프로세스의 수행은 반드시 순차적이어야 한다. CPU는 그 프로세스가 끝날 때까지
그 프로세스의 명령들을 차례대로 수행한다. 게다가, 어느 한순간에는 많아야 그 프로세스를 위해 하나의
명령만 수행된다. 따라서 두 개의 프로세스가 동일한 프로그램과 연관되어 있더라도, 그들은 두 개의
별도의 수행 순서로 간주된다. 다중 스레드 프로세스는 여러 개의 프로그램 카운터를 가지고 있으며
이 카운터들은 각 스레드가 실행할 다음 명령어를 가리키게 된다.

한 프로세스는 한 시스템 내의 작업의 단위이다. 이러한 시스템은 프로세스의 집합으로 구성되는데,
프로세스 중 일부는 운영체제 프로세스들이며, 나머지는 사용자 프로세스들이다.
이러한 모든 프로세스는 단일 CPU 코어에서 멀티플렉싱하거나 여러 CPU 코어에서 병렬로 병행하게
실행할 수 있다. 운영체제는 프로세스 관리와 연관해 다음과 같은 활동에 대한 책임을 진다.

- 사용자 프로세스와 시스템 프로세스의 생성과 제거
- CPU에 프로세스와 스레드 스케줄하기
- 프로세스의 일시 중지와 재수행
- 프로세스 동기화를 위한 기법 제공
- 프로세스 통신을 위한 기법 제공

### 메모리 관리(Memeory Management)

메인 메모리는 현대 컴퓨터 시스템의 작동에 중추적인 역할을 한다. 메모리는 크기가 수십 만에서
수십 억까지의 범위를 갖는 바이트의 대용량 배열이다. **각 바이트는 자신의 주소를 가진다.**
메인 메모리는 CPU와 입출력 장치에 의하여 공유되는, 빠른 접근이 가능한 데이터의 저장소이다.
폰 노이만 방식의 컴퓨터에서는 CPU가 명령어 인출 사이클(instruction fetch-cycle)
동안 메인 메모리로부터 명령어를 읽고, 자료 인출 사이클(data fetch-cycle) 동안 메인
메모리로부터 데이터를 읽고 또한 쓴다.

프로그램이 수행되기 위해서는 반드시 절대 주소로 매핑(mapping)되어야 하고 메모리에
적재되어야 한다. 프로그램을 수행하면서, 이러한 절대 주소를 생성하여 메모리의 프로그램 명령어와
데이터에 접근한다. 결국, 프로그램이 종료되고, 프로그램이 차지하던 메모리 공간은 가용공간으로
선언되고, 다음 프로그램이 적재되어 수행될 수 있다.

CPU 이용률과 사용자에 대한 컴퓨터의 응답 속도를 개선하기 위해, 우리는 메모리에 여러개의
프로그램을 유지해야 하며 이를 위해서 메모리 관리 기법이 필요하다. 이러한 메모리 관리
기법에는 여러 종류가 있다. 이러한 기법은 메모리 관리에 대한 여러 접근 방법을 반영하는데,
각 알고리즘의 효율성은 특정 상황에 따라 다르다. 특정 시스템에 대한 메모리 관리 기법의
선택은 여러 요인에 의해 결정되지만, 특히 시스템의 하드웨어 설계에 좌우된다.

### 파일 시스템 관리(File System Management)

운영체제는 저장장치의 물리적 특성을 추상화하여 논리적인 저장 단위인 파일을 정의한다.
운영체제는 파일을 물리적 매체로 매핑하여, 저장장치를 통해 이들 파일에 접근한다.

파일은 파일 생성자에 의해 정의된 관련 정보의 집합체이다. 일반적으로 파일은 프로그램과
테이터를 나타낸다. 데이터 파일은 숫자, 영문자, 영숫자 등으로 구성된다.

운영체제는 대량 저장 매체와 그것을 제어하는 장치를 관리함으로써 파일의 추상적인 개념을
구현한다. 또한, 파일은 사용하기 쉽도록 통상 디렉터리들로 구성된다. 다수의 사용자가
파일에 접근하려고 할 때는 누구에 의해서, 그리고 어떤 방법으로 파일이 접근되어야
하는가를 통제하는 것이 바람직하다.

운영체제는 파일 관리를 위하여 다음과 같은 일을 담당한다.

- 파일의 생성 및 제거
- 디렉터리의 생성 및 제거
- 파일과 디렉터리를 조작하기 위한 프리미티브의 제공
- 파일을 보조저장장치로 매핑
- 안정적인(비휘발성) 저장 매체에 파일을 백업

### 대용량 저장장치 관리(Mass Storage Management)

운영체제는 보조저장장치 관리와 관련하여 다음 활동을 담당한다.

- 마운팅과 언마운팅
- 사용 가능 공간(free-space)의 관리
- 저장장소 할당
- 디스크 스케줄링
- 저장장치 분할
- 보호

보조저장장치는 매우 빈번하게 폭넓게 사용되므로, 효율적으로 사용해야 한다.
컴퓨터의 전체 동작 속도는 보조저장장치 서브시스템과 그것을 조작하는 알고리즘의 속도에
의해 결정될 수 있다. 동시에 보조저장장치보다 더 느리고 비용은 적게 들고 때로는 용량이 더 큰
장치를 필요로 하는 경우도 많다. 디스크 데이터 백업, 가끔 쓰이는 데이터 및 장기간 보존이
필요한 데이터를 저장하는 것이 대표적인 예이다. 자기 데이프 드라이브와 그 테이프, CD와
DVD 및 Blu-ray 드라이브와 플래터들은 전형적인 3차 저장장치의 예이다.

3차 저장장치는 시스템 성능에는 중요하지 않지만 운영체제에 의해 관리되어야만 한다. 어떤
운영체제들은 이 역할을 직접 수행하며 다른 운영체제들은 이 역할을 응용 프로그램에게 맡기기도
한다. 운영체제가 제공해야 할 기능에는 마운트와 언마운트 기능, 프로세스의 배타적 사용을 위한
장치의 할당과 반환 그리고 보조저장장치로부터 3차 저장장치로의 데이터 이주 등이 포함된다.

### 캐시 관리(Cache Management)

캐싱은 컴퓨터 시스템의 중요한 원리이다. 정보는 통상 어떤 저장장치(메인 메모리와 같은)에
보관된다. 정보가 사용됨에 따라, 더 빠른 장치인 캐시에 일시적으로 복사된다. 그리므로
우리가 특정 정보가 필요할 경우, 우리는 먼저 캐시에 그 정보가 있는지를 조사해 보아야 한다.
만약 캐시에 없다면 메인 메모리 시스템으로부터 그 정보를 가져와서 사용해야 하며, 이 때
이 정보가 다음에 곧 다시 사용될 확률이 높다는 가정하에 캐시에 넣는다.

게다가 CPU 내부의 프로그램 가능한 레지스터들은 메인 메모리를 위한 고속의 캐시로 볼 수 있다.
프로그래머는 어느 정보를 메인 메모리에 두고, 어느 정보를 레지스터에 둘 것인지를 결정하는
레지스터 할당 정책과 교체 알고리즘을 구현한다.

전적으로 하드웨어로 구현된 캐시도 있다. 예를 들어, 시스템 대부분은 다음에 수행될 것으로
예상되는 명령을 넣어 두는 명령 캐시를 가지고 있다. 만약 명령 캐시가 없다면 CPU는 메인
메모리로부터 다음 명령을 인출해 올 동안 몇 사이클을 기다려야 한다. 유사한 이유로 시스템
대부분은 하나 이상의 고속 데이터 캐시를 가지고 있다.

캐시 크기가 제한되어 있으므로 캐시 관리는 중요한 설계 문제이다. 캐시 크기와 교체 정책을
신중하게 선택하면 성능이 크게 향상될 수 있다.

저장장치의 계층 구조에서 각 수준 간의 정보 이동은 하드웨어 설계나 제어하는 운영체제에
따라 명시적 또는 묵시적으로 이루어진다. 예를 들어, 캐시로부터 CPU 및 레지스터로의
데이터 전송은 통상 운영체제의 간섭 없이 하드웨어적으로 이루어진다.

<Image
  src="https://user-images.githubusercontent.com/63354527/213860197-6dbeb6cd-e5d0-4e47-b6a6-858dbf1dd14d.png"
  description="다양한 유형의 저장장치의 특성"
  referenceLink="https://user-images.githubusercontent.com/63354527/213860197-6dbeb6cd-e5d0-4e47-b6a6-858dbf1dd14d.png"
/>

<Image
  src="https://user-images.githubusercontent.com/63354527/213860266-d9e4dfe3-e997-42ee-bb82-1d0db7ce8e68.png"
  description="정수 A를 디스크로부터 레지스터로 이동하는 과정"
  referenceLink="https://user-images.githubusercontent.com/63354527/213860266-d9e4dfe3-e997-42ee-bb82-1d0db7ce8e68.png"
/>

<br />

### 입출력 시스템 관리(I/O System Management)

운영체제의 목적 중의 하나는 사용자에게 특정 하드웨어 장치의 특성을 숨기는 것이다.
예를 들면, UNIX에서 입출력 장치의 특성은 입출력 서브시스템에 의해 운영체제 자체의
대부분으로부터 숨겨져 있다. 입출력 시스템은 다음과 같이 구성되어 있다.

- 버퍼링, 캐싱, 스풀링을 포함한 메모리 관리 구성요소
- 특정 하드웨어 장치들을 위한 드라이버

## 보안과 보호(Security and Protection)

만일 컴퓨터 시스템이 다수의 사용자를 가지며 다수 프로세스의 병행 수행을 허용한다면,
데이터에 대한 접근은 반드시 규제되어야 한다. 이를 위해 파일, 메모리 세그먼트, CPU 및
다른 자원들에 대해 운영체제로부터 적절한 허가를 획득한 프로세스만이 작업할 수 있도록
보장하는 기법이 필요하다. 예를 들면, 메모리 주소지정 하드웨어는 프로세스가 자신의 주소
영역에서만 실행될 수 있도록 보장한다. 타이머는 모든 프로세스가 CPU의 제어를 얻은 후
결국에는 제어를 양도하도록 보장한다. 여러 주변 장치의 무결성이 보장받도록, 장치 제어
레지스터들에 사용자가 접근할 수 없게 한다.

**보호**(protection)이란 컴퓨터 시스템이 정의한 자원에 대해 프로그램, 프로세스, 또는
사용자들의 접근을 제어하는 기법이다. 이 기법은 시행될 제어에 대한 명세와 이들을 강제
시행하는 방법을 규정하는 수단을 반드시 제공해야 한다. 보호는 구성요소 서브 시스템 간의
인터페이스 오류를 초기에 발견하면 종종 고장 난 서브시스템에 의해 정상적인 서브시스템이
오염되는 것을 방지할 수 있다. 보호되지 않는 자원은 권한이 없거나 또는 무자격 사용자에
의해 사용(또는 오용)되는 것을 방지할 수 없다.

컴퓨터 시스템은 충분한 보호 기능이 있더라도 여전히 고장이 나거나 부적절한 접근을 허용할
수 있다. 사용자 인증 정보(사용자가 자신임을 시스템에 알릴 수 있는 방법)가 도난당했다고
가정하자. 파일과 메모리 보호 기능이 작동하더라도 사용자의 데이터는 복사 또는 삭제 될 수
있다. 이러한 외부 또는 내부의 공격을 방어하는 것이 바로 보안 기능이다.

보호와 보안을 제공하기 위해서는 시스템의 모든 사용자를 구분할 수 있어야 한다. 운영체제의
대부분은 사용자 이름과 관련된 사용자 식별자(user IDs)의 리스트를 유지한다. Windows
용어로는 보안 식별자(security ID, SID)라고 한다. 이 식별자는 사용자마다 할당되고
시스템에서 유일한 값을 가진다.

사용자가 로그인 할 때 인증 단계에서 사용자에게 맞는 적절한 식별자를 결정한다.
이 사용자 식별자는 사용자의 모든 프로세스나 스레드에 연관된다. 식별자를 사용자가 읽어야 할
필요가 있을 때 사용자 이름 리스트를 통해 원래의 사용자 이름으로 변환된다.

시스템을 정상적으로 사용하는 동안 사용자 식별자와 그룹 식별자만 있으면 충분하다. 그러나
사용자는 때때로 원하는 작업을 수행하기 위해서는 권한을 상승해야 할 때가 있다. 예를 들어
사용자가 제한된 장치에 접근해야 할 때도 있다. 운영체제는 권한 상승을 허용하는 다양한 방법을
제공한다. 예를 들면 UNIX에서는 프로그램이 수행될 때 setuid 속성을 이용하여 현 사용자의
식별자가 아니라 접근하려고 하는 파일의 소요주 식별자를 이용하여 동작할 수 있다. 프로세스는
종료되거나 특권을 해제하기 전까지 이 유효 사용자 식별자(effective user ID)를 이용하여
수행된다.

## 가상화(Virtualization)

가상화는 단일 컴퓨터의 하드웨어를 여러 가지 실행 환경으로 추상화하여 개발 환경이 자신만의
컴퓨터에서 실행되고 있다는 환상을 만들 수 있는 기술이다. 이러한 환경은 동시에 실행되고
서로 상호 작용할 수 있는 다른 개별 운영체제(Windows 및 UNIX)로 볼 수 있다.
가상 머신의 사용자는 단일 운영체제에서 동시에 실행되는 다양한 프로세스 간에 전환할 수 있는
것과 동일한 방식으로 다양한 운영체제 간에 전환할 수 있다.

가상화는 운영체제가 다른 운영체제 내에서 하나의 응용프로그램처럼 수행될 수 있게 한다.
넓게 말하면 가상화 소프트웨어는 에뮬레이션을 포함하는 클래스의 구성원이다. 소프트웨어로
컴퓨터 하드워어 시뮬레이션 하는 에뮬레이션은 일반적으로 소스 CPU 유형이 대상 CPU 유형과
다른 경우에 사용된다.

에뮬레이션은 비용이 크다. 소스 시스템에서 수행되는 기계어 수준의 모든 명령은 목표 시스템에서
동등한 기능으로 번역되어야 하고, 종종 이는 여러 개의 목표 명령어가 되기도 한다. 만일 소스와
목표 CPU가 비슷한 성능 수준일 경우 에뮬레이트된 코드는 원래의 코드보다 훨씬 느리게
수행된다.

이와 달리 가상화에서는 특정 CPU를 위해 컴파일된 운영체제가 동일 CPU용의 다른 운영체제
내에서 수행된다. 가상화는 다수 사용자가 작업을 병행 수행하기 위한 방법으로 IBM 대형컴퓨터에
처음 등장하였다. 다수의 가상 기계를 수행함으로써 많은 사용자들이 단일 사용자를 위해 설계된
시스템에서 작업을 수행할 수 있게 되었다. 후에 다수의 Microsoft Windows 애플리케이션을
인텔 x86 CPU에 수행하는 문제를 해결하기 위해 VMware가 Windows 상에서 수행되는
애플리케이션의 형태로 새로운 가상화 기술을 만들었다. 이 애플리케이션은 게스트라 불리는 하나
이상의 Windows나 다른 x86용 운영체제 복사본들을 수행하며 각 게스트는 자신의 애플리케이션을
수행한다. Winodws는 호스트 운영체제이고 VMware 응용프로그램은 가상 머신 관리자(VMM)이다.
VMM은 게스트 운영체제를 수행하고 그들의 자원 이용을 관리하며 각 게스트를 서로로부터 보호한다.

현대의 운영체제가 다수의 응용 프로그램을 신뢰성 있게 수행할 능력이 있다고 해도, 가상화의
이용은 지속해서 성장하고 있다. 랩톱과 데스크톱에서 VMM은 체험을 위하거나 또는 다른
호스트용으로 작성된 운영체제상의 응용 프로그램을 수행하기 위해 다수의 운영체제를
설치할 수 있게 한다.

<Image
  src="https://user-images.githubusercontent.com/63354527/213861620-44f4e2d5-8201-4d8c-a273-585164de10c6.png"
  description="(a) 하나의 운영체제와 (b) 3개의 가상 머신을 실행시키는 컴퓨터"
  referenceLink="https://user-images.githubusercontent.com/63354527/213861620-44f4e2d5-8201-4d8c-a273-585164de10c6.png"
/>

## 분산 시스템(Distributed Systems)

분산 시스템은 물리적으로 떨어져 있는 이기종 컴퓨터들의 집합이다. 분산 시스템의 컴퓨터들은
사용자가 시스템 내의 다양한 자원들을 접근할 수 있도록 네트워크로 연결되어 있다.

공유 자원에 대한 접근은 계산 속도와 기능, 데이터 가용성 및 신뢰성을 향상시킨다. 몇몇
운영체제는 네트워킹의 자세한 사항을 네트워크 인터페이스의 장치 드라이버에 포함시킴으로써
네트워크에 대한 접근을 파일 접근 형태로 일반화시킨다. 다른 운영체제들은 사용자가 특정
네트워크 기능을 명시적으로 호출하게 한다. 일반적으로 시스템 상에는 두 모드가 혼재되어
있으며 그 예로 FTP와 NFS를 들 수 있다.

네트워크는 가장 단순하게 보면 두개 이상의 시스템 간의 통신 경로이다. 분산 시스템의 많은
기능은 네트워킹에 의존하고 있다. 네트워크는 사용되는 프로토콜, 노드 간의 거리 그리고
전송 매체에 따라 다르다. 비록 ATM과 여타 프로토콜들이 널리 사용되고 모든 범용 운영체제를
포함하여 운영체제 대부분은 TCP/IP를 지원한다. 운영체제 입장에서 네트워크 프로토콜은
인터페이스 장치(예: 네트워크 어댑터 등), 이를 관리하는 장치 드라이버 및 데이터를 처리하는
소프트웨어가 있어야 한다. 네트워크는 노드 간의 거리에 의해 유형이 결정된다. 근거리 통신망
(LAN)은 한 방, 한 층, 한 건물에 존재한다. 광역 통신망(WAN)은 통산 건물, 도시 또는
국가 사이를 연결한다.

일부운영체제는 네트워크 연결 제공 개념을 넘어서서 네트워크 및 분산 시스템 개념을 취했다.
네트워크 운영체제는 다른 컴퓨터의 다른 프로세스가 메시지를 교환할 수 있도록 하는 통신
체계와 함께 네트워크를 통한 파일 공유와 같은 기능을 제공하는 운영체제이다.

네트워크 운영체제를 실행하는 컴퓨터는 네트워크를 인식하고 다른 네트워크 컴퓨터와 통신할 수
있지만 네트워크의 다른 모든 컴퓨터와는 자율적으로 작동한다. 분산 운영체제는 그에 비해 덜
자율적인 환경을 제공한다. 하나의 운영체제가 네트워크를 제어하는 것처럼 보이기 위해 여러
컴퓨터가 밀접하게 통신한다.
