---
title: CPU 스케줄링 알고리즘
description: 운영체제의 CPU 스케줄링 알고리즘에 대해 알아봅니다.
tags:
  - CPU
  - 스케줄링
---

## 선입 선처리 스케줄링(First Come First Served Scheduling)

선입 선처리 스케줄링은 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식입니다. 즉, 선입 선처리 스케줄링은 CPU를 먼저 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식입니다. 선입 선처리 스케줄링은 언뜻 보기에는 가장 공정해 보이지만, 때로는 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 점에서 부작용이 있는 방식입니다.

가령 CPU를 오래 사용하는 프로세스가 먼저 도착하면 다른 프로세스는 그 프로세스가 CPU를 사용하는 동안 무작정 기다리는 수밖에 없습니다.
예를 들어 17ms동안 CPU를 이용하는 프로세스 A, 5ms동안 CPU를 이용하는 프로세스 B, 2ms동안 CPU를 이용하는 프로세스 C가 차례로 준비 큐에 삽입된다면 프로세스 C는 고작 2ms를 실행하기 위해 22ms(17ms + 5ms)라는 긴 시간을 기다려야만 합니다.

이런 현상을 `**호위 효과(convoy effect)**`라고 합니다.

## 최단 작업 우선 스케줄링(Shortest Job First Scheduling)

준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식을 최단 작업 우선 스케줄링 혹은 SJF 스케줄링이라고 합니다.  
최단 작업 우선 스케줄링은 기본적으로 비선점형 스케줄링으로 분류되지만, 선점형으로 구현될 수도 있습니다.

## 라운드 로빈 스케줄링(Round Robin Scheduling)

라운드 로빈 스케줄링은 선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식입니다. 타임 슬라이스란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미합니다.
즉, 라운드 로빈 스케줄링은 정해진 타입 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링입니다.

큐에 삽입된 프로세스들은 삽입된 순서대로 CPU를 정해진 시간만큼만 이용하고 정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입됩니다. 이때 문맥 교환이 발생합니다.

라운드 로빈 스케줄링에서는 타임 슬라이스의 크기가 매우 중요합니다.  
타임 슬라이스의 크기가 지나치게 크면 사실상 선입 선처리 스케줄링과 다를 바 없어 호위 효과가 생길 여지가 있고, 타임 슬라이스가 지나치게 작으면 문맥 교환에 발생하는 비용이 커 CPU는 프로세스를 처리하는 일보다 프로세스를 전환하는 데에 온 힘을 다 쓸 여지가 있기 때문입니다.

## 최소 잔여 시간 우선 스케줄링(Shortest Remaining Time)

최단 작업 우선 스케줄링 알고리즘과 라운드 로빈 스케줄링 알고리즘을 결합한 스케줄링 방식입니다.  
최단 작업 우선 스케줄링은 작업 시간이 짧은 프로세스부터 처리하는 스케줄링 알고리즘이고, 라운드 로빈은 정해진 타임 슬라이스만큼 돌아가며 CPU를 사용하는 선점형 스케줄링 알고리즘입니다.  
최소 잔여 시간 우선 스케줄링 하에서 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택됩니다.

## 우선순위 스케줄링(Priority Scheduling)

우선순위 스케줄링은 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘입니다.

우선순위 스케줄링은 근본적인 문제를 내포하고 있습니다.
우선순위가 높은 프로세스를 우선 처리하는 방식이기에 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스에 의해 실행이 계속해서 연기될 수 있습니다.
이를 `기아(starvation)현상`이라고 합니다. 우선순위가 높은 프로세스만 계속 먼저 실행되니 우선순위가 낮은 프로세스의 실행은 계속 뒤로 밀리는 것이죠.
